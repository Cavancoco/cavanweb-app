import * as React from 'react';
export interface FlexibleProps {
	[key: string]: any
}

/**
 * 
 * The base class of every Canvas D3 Component that can also be used standalone.
 * 
 */
declare class D3_Canvas extends React.Component<D3_CanvasProps, any> { }
export interface D3_CanvasProps extends FlexibleProps {

	/**
	 * An object containing ARIA attributes to be set
	 * on this Component's ARIA element. Use this to set the attributes that cannot be
	 * determined by the Component's state, such as `aria-live`, `aria-flowto`, etc.
	 * 
	 * **Note** that this config is only meaningful at the Component rendering time,
	 * and setting it after that will do nothing.
	 * 
	 */
	ariaAttributes?: any

	/**
	 * DOM selector for a child element that is to be used
	 * as description for this Component, set in `aria-describedby` attribute.
	 * The selector works the same way as ariaLabelledBy.
	 * 
	 */
	ariaDescribedBy?: string

	/**
	 * ARIA label for this Component. It is best to use
	 * ariaLabelledBy option instead, because screen readers prefer
	 * `aria-labelledby` attribute to `aria-label`. ariaLabel and
	 * ariaLabelledBy config options are mutually exclusive.
	 * 
	 */
	ariaLabel?: string

	/**
	 * DOM selector for a child element that is to be used
	 * as label for this Component, set in `aria-labelledby` attribute.
	 * If the selector is by `#id`, the label element can be any existing element,
	 * not necessarily a child of the main Component element.
	 * 
	 * ariaLabelledBy and ariaLabel config options are
	 * mutually exclusive, and `ariaLabelledBy` has the higher precedence.
	 * 
	 */
	ariaLabelledBy?: string

	/**
	 * If `true`, then, when showBy or alignTo fallback on
	 * constraint violation only takes place along the major align axis.
	 * 
	 * That is, if alignment `"l-r"` is being used, and `axisLock: true` is used, then if constraints
	 * fail, only fallback to `"r-l"` is considered.
	 * 
	 */
	axisLock?: boolean

	/**
	 * 
	 * Enables or disables bordering on this component.
	 * The following values are accepted:
	 * 
	 * - `null` or `true (default): Do nothing and allow the border to be specified by the theme.
	 * - `false`: suppress the default border provided by the theme.
	 * 
	 * Please note that enabling bordering via this config will not add a `border-color`
	 * or `border-style` CSS property to the component; you provide the `border-color`
	 * and `border-style` via CSS rule or style configuration
	 * (if not already provide by the theme).
	 * 
	 */
	border?: boolean

	/**
	 * The absolute bottom position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	bottom?: number | string

	/**
	 * Configure this as `true` to have this Component centered within its Container.
	 * Setting this value to `true` will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	centered?: boolean

	/**
	 * The CSS class to add to this widget's element, in
	 * addition to the baseCls. In many cases, this property will be specified
	 * by the derived widget class. See userCls for adding additional CSS
	 * classes to widget instances (such as items in a Ext.Container).
	 * 
	 */
	cls?: string | string[]

	/**
	 * The CSS class used by a subclass of the D3 Component.
	 * Normally, the lower-cased name of a subclass.
	 * 
	 */
	componentCls?: string

	/**
	 * The configured element will automatically be
	 * added as the content of this component. When you pass a string, we expect it to be an element id.
	 * If the content element is hidden, we will automatically show it.
	 * 
	 */
	contentEl?: any | HTMLElement | string

	/**
	 * The initial set of data to apply to the `tpl` to
	 * update the content area of the Component.
	 * 
	 */
	data?: any

	/**
	 * Whether or not this component is disabled
	 * 
	 */
	disabled?: boolean

	/**
	 * The dock position of this component in its container. Can be `left`, `top`, `right` or `bottom`.
	 * 
	 * __Notes__
	 * 
	 * You must use a HTML5 doctype for docked `bottom` to work. To do this, simply add the following code to the HTML file:
	 * 
	 *     <!doctype html>
	 * 
	 * So your index.html file should look a little like this:
	 * 
	 *     <!doctype html>
	 *     <html>
	 *         <head>
	 *             <title>MY application title</title>
	 *             ...
	 * 
	 */
	docked?: string

	/**
	 * Configuration options to make this Component draggable
	 * 
	 */
	draggable?: any

	/**
	 * CSS class that will be added to focused
	 * component's focusClsEl, and removed when component blurs.
	 * 
	 */
	focusCls?: string

	/**
	 * Force the component to take up 100% width and height available, by adding it
	 * to Ext.Viewport.
	 * 
	 */
	fullscreen?: boolean

	/**
	 * If `true`, will automatically override Canvas context ('2d') methods
	 * when running on HDPI displays. Setting this to 'false' will greatly
	 * improve performance on such devices at the cost of image quality.
	 * It can also be useful when this class is used in conjunction with
	 * another Canvas library that provides HDPI support as well.
	 * Once set cannot be changed.
	 * 
	 */
	hdpi?: boolean

	/**
	 * The height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	height?: number | string

	/**
	 * Whether or not this Component is hidden (its CSS `display` property is set to `none`).
	 * 
	 * Defaults to `true` for floated Components.
	 * 
	 */
	hidden?: boolean

	/**
	 * Animation effect to apply when the Component is being hidden.  Typically you want to use an
	 * outbound animation type such as 'fadeOut' or 'slideOut'. For more animations, check the Ext.fx.Animation#type config.
	 * 
	 */
	hideAnimation?: string | any

	/**
	 * When using a cfg!modal Component, setting this to `true`
	 * will hide the modal mask and the Container when the mask is tapped on.
	 * 
	 */
	hideOnMaskTap?: boolean

	/**
	 * Optional HTML content to render inside this Component, or a reference
	 * to an existing element on the page.
	 * 
	 */
	html?: string | any | HTMLElement

	/**
	 * The list of interaction configs for this D3 component.
	 * D3 package interactions are very similar to native D3 behaviors.
	 * However, D3 behaviors, as well as event system, is incompatible
	 * with ExtJS event system. D3 package interactions may also support
	 * certain features that D3 behaviors lack, like like kinetic scrolling,
	 * elastic borders and scroll indicators (see the Ext.d3.interaction.PanZoom
	 * interaction for more information).
	 * 
	 */
	interactions?: any[]

	/**
	 * An object containing handlers for keyboard events. The property names of this
	 * object are the key name and any modifiers. The values of the properties are the
	 * descriptors of how to handle each event.
	 * 
	 * The handler descriptor can be simply the handler function (either the
	 * literal function or the method name), or it can be an object with these
	 * properties:
	 * 
	 *  - `handler`: The function or its name to call to handle the event.
	 *  - `scope`: The this pointer context (can be "this" or "controller").
	 *  - `event`: An optional override of the key event to which to listen.
	 * 
	 * **Important:** Calls to `setKeyMap` do not replace the entire `keyMap` but
	 * instead update the provided mappings. That is, unless `null` is passed as the
	 * value of the `keyMap` which will clear the `keyMap` of all entries.
	 * 
	 */
	keyMap?: any

	/**
	 * Enables or disables processing keys in the `keyMap`. This value starts as
	 * `null` and if it is `null` when `initKeyMap` is called, it will automatically
	 * be set to `true`. Since `initKeyMap` is called by `Ext.Component` at the
	 * proper time, this is not something application code normally handles.
	 * 
	 */
	keyMapEnabled?: boolean

	/**
	 * The absolute left position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	left?: number | string

	/**
	 * 
	 * A config object containing one or more event handlers to be added to this object during initialization. This
	 * should be a valid listeners config object as specified in the
	 * addListener example for attaching
	 * multiple handlers at once.
	 * 
	 * **DOM events from Ext JS Ext.Component**
	 * 
	 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
	 * only done when extra value can be added. For example the DataView's **`itemclick`** event passing the node clicked on. To access DOM events directly from a
	 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
	 * DOM listener to:
	 * 
	 *     new Ext.panel.Panel({
	 *         width: 400,
	 *         height: 200,
	 *         dockedItems: [{
	 *             xtype: 'toolbar'
	 *         }],
	 *         listeners: {
	 *             click: {
	 *                 element: 'el', //bind to the underlying el property on the panel
	 *                 fn: function(){ console.log('click el'); }
	 *             },
	 *             dblclick: {
	 *                 element: 'body', //bind to the underlying body property on the panel
	 *                 fn: function(){ console.log('dblclick body'); }
	 *             }
	 *         }
	 *     });
	 * 
	 */
	listeners?: any

	/**
	 * The margin to use on this Component. Can be specified as a number (in which case
	 * all edges get the same margin) or a CSS string like '5 10 10 10'
	 * 
	 */
	margin?: number | string

	/**
	 * The maximum height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * Note that this config will not apply if the Component is 'positioned' (absolutely positioned or centered)
	 * 
	 */
	maxHeight?: number | string

	/**
	 * The maximum width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * Note that this config will not apply if the Component is 'positioned' (absolutely positioned or centered)
	 * 
	 */
	maxWidth?: number | string

	/**
	 * The minimum height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	minHeight?: number | string

	/**
	 * The minimum width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	minWidth?: number | string

	/**
	 * `true` to make this Component modal. This will create a mask underneath the Component
	 * that covers its parent and does not allow the user to interact with any other Components until this
	 * Component is dismissed.
	 * 
	 */
	modal?: boolean

	/**
	 * Name for the widget to be used with Ext.Container#lookupName et al.
	 * 
	 */
	name?: string

	/**
	 * The padding to use on this Component. Can be specified as a number (in which
	 * case all edges get the same padding) or a CSS string like '5 10 10 10'
	 * 
	 */
	padding?: number | string

	/**
	 * An object or array of objects that will provide custom functionality for this
	 * component. If a string is provided or a string is one of the elements of the
	 * array, that string is treated as the `type` alias. For example, "listpaging"
	 * is the type alias for `Ext.plugin.ListPaging`. The full alias includes the
	 * "plugin." prefix (i.e., 'plugin.listpaging').
	 * 
	 * Plugins should derive from `Ext.plugin.Abstract` but this is not required. The
	 * only requirement for a valid plugin is that it contain an `init()` method that
	 * accepts a reference to the owning component.
	 * 
	 * When a component is created, if any plugins are available, the component will
	 * call the `init` method on each plugin,
	 * passing a reference to itself. Each plugin can then call methods or respond to
	 * events on the component as needed to provide its functionality.
	 * 
	 * ## Example code
	 * 
	 * A plugin by alias:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: 'listpaging'
	 *      });
	 * 
	 * Multiple plugins by alias:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: ['listpaging', 'pullrefresh']
	 *      });
	 * 
	 * Single plugin by class name with config options:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: {
	 *              type: 'listpaging',
	 *              autoPaging: true
	 *          }
	 *      });
	 * 
	 * Multiple plugins by type and class name with config options:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: [{
	 *              xclass: 'Ext.plugin.PullRefresh',
	 *              pullRefreshText: 'Pull to refresh...'
	 *          }, {
	 *              type: 'listpaging',
	 *              autoPaging: true
	 *          }]
	 *      });
	 * 
	 */
	plugins?: any | string | any[] | string[]

	/**
	 * A model instance which updates the Component's html based on it's tpl. Similar to the data
	 * configuration, but tied to to a record to make allow dynamic updates.  This must be a model
	 * instance and not a configuration of one.
	 * 
	 */
	record?: any

	/**
	 * Optional element to render this Component to.
	 * Not required if this component is an item of a Container of a Container.
	 * 
	 */
	renderTo?: any

	/**
	 * The absolute right position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	right?: number | string

	/**
	 * Configuration options to make this Component scrollable. Acceptable values are:
	 * 
	 * - `true` to enable auto scrolling.
	 * - `false` (or `null`) to disable scrolling - this is the default.
	 * - `x` or `horizontal` to enable horizontal scrolling only
	 * - `y` or `vertical` to enable vertical scrolling only
	 * 
	 * Also accepts a configuration object for a `Ext.scroll.Scroller` if
	 * if advanced configuration is needed.
	 * 
	 * The getter for this config returns the Ext.scroll.Scroller
	 * instance.  You can use the Scroller API to read or manipulate the scroll position:
	 * 
	 *     // scrolls the component to 5 on the x axis and 10 on the y axis
	 *     component.getScrollable().scrollTo(5, 10);
	 * 
	 */
	scrollable?: boolean | string | any

	/**
	 * Animation effect to apply when the Component is being shown.  Typically you want to use an
	 * inbound animation type such as 'fadeIn' or 'slideIn'. For more animations, check the Ext.fx.Animation#type config.
	 * 
	 */
	showAnimation?: string | any

	/**
	 * Whether or not the component got its first size.
	 * Can be used in the `canvasresize` event handler to do user-defined setup on first
	 * resize, for example:
	 * 
	 *     listeners: {
	 *         canvasresize: function (component, canvas, rect) {
	 *             if (!component.size) {
	 *                 // set things up
	 *             } else {
	 *                 // handle resize
	 *             }
	 *         }
	 *     }
	 * 
	 */
	size?: any

	/**
	 * The store with data to render.
	 * 
	 */
	store?: any

	/**
	 * Additional CSS styles that will be rendered into an inline style attribute when
	 * the widget is rendered.
	 * 
	 * You can pass either a string syntax:
	 * 
	 *     style: 'background:red'
	 * 
	 * Or by using an object:
	 * 
	 *     style: {
	 *         background: 'red'
	 *     }
	 * 
	 * When using the object syntax, you can define CSS Properties by using a string:
	 * 
	 *     style: {
	 *         'border-left': '1px solid red'
	 *     }
	 * 
	 * Although the object syntax is much easier to read, we suggest you to use the
	 * string syntax for better performance.
	 * 
	 */
	style?: string | any

	/**
	 * DOM tabIndex attribute for this component's focusEl.
	 * 
	 */
	tabIndex?: number

	/**
	 * The Ext.tip.ToolTip for this component.
	 * 
	 *     <Button text="Basic Tip">
	 *         <ToolTip>A simple tooltip</ToolTip>
	 *     </Button>
	 * 
	 */
	tooltip?: any

	/**
	 * The absolute top position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	top?: number | string

	/**
	 * 
	 * Emulates the behavior of the CSS [touch-action](https://www.w3.org/TR/pointerevents/#the-touch-action-css-property)
	 * property in a cross-browser compatible manner.
	 * 
	 * Keys in this object are touch action names, and values are `false` to disable
	 * a touch action or `true` to enable it.  Accepted keys are:
	 * 
	 * - `panX`
	 * - `panY`
	 * - `pinchZoom`
	 * - `doubleTapZoom`
	 * 
	 * All touch actions are enabled (`true`) by default, so it is usually only necessary
	 * to specify which touch actions to disable.  For example, the following disables
	 * only horizontal scrolling and pinch-to-zoom on the component's main element:
	 * 
	 *     touchAction: {
	 *         panX: false,
	 *         pinchZoom: false
	 *     }
	 * 
	 * Touch actions can be specified on reference elements using the reference element
	 * name, for example:
	 * 
	 *     // disables horizontal scrolling on the main element, and double-tap-zoom
	 *     // on the child element named "body"
	 *     touchAction: {
	 *         panY: false
	 *         body: {
	 *             doubleTapZoom: false
	 *         }
	 *     }
	 * 
	 * The primary motivation for setting the touch-action of an element is to prevent
	 * the browser's default handling of a gesture such as pinch-to-zoom, or
	 * drag-to-scroll, so that the application can implement its own handling of that
	 * gesture on the element.  Suppose, for example, a component has a custom drag
	 * handler on its element and wishes to prevent horizontal scrolling of its container
	 * while it is being dragged:
	 * 
	 *     Ext.create('Ext.Widget', {
	 *         touchAction: {
	 *             panX: false
	 *         },
	 *         listeners: {
	 *             drag: function(e) {
	 *                 // implement drag logic
	 *             }
	 *         }
	 *     });
	 * 
	 */
	touchAction?: any

	/**
	 * 
	 * A string, array of strings, or a function that returns JSX.
	 * 
	 *    tpl = data => <div>{data.first_name} {data.last_name}</div>
	 * 
	 * __Note__
	 * The data configuration _must_ be set for any content to be shown in the component when using this configuration.
	 * 
	 */
	tpl?: Function | string | string[]

	/**
	 * The Ext.(X)Template method to use when updating the content area of the Component.
	 * 
	 * Valid modes are:
	 * 
	 * - append
	 * - insertAfter
	 * - insertBefore
	 * - insertFirst
	 * - overwrite
	 * 
	 */
	tplWriteMode?: string

	/**
	 * A map of transition configs. For example:
	 * 
	 *     transitions: {
	 *         select: {
	 *             duration: 500,
	 *             ease: 'cubicInOut'
	 *         },
	 *         zoom: {
	 *             name: 'zoom',
	 *             duration: 1000
	 *         },
	 *         ...
	 *     }
	 * 
	 * A class would define the defaults for its transitions, and a user only needs
	 * to set the `transitions` config of an instance to disable a transition, e.g.:
	 * 
	 *     transitions: {
	 *         // transitions are enabled by default, `true` should never be used here
	 *         select: false
	 *     }
	 * 
	 * or alter its config:
	 * 
	 *     transitions: {
	 *         select: {
	 *             // the `duration` stays the same,
	 *             // only the easing function is altered
	 *             ease: 'bounceOut'
	 *         }
	 *     }
	 * 
	 * The transitions defined this way are merely configs. To create an actual transition
	 * from one of these configs, use the createTransition method. For example:
	 * 
	 *     this.createTransition('select')
	 * 
	 * A transition object can optionally specify a name, if it's different from
	 * the key in the `transitions` config. For example:
	 * 
	 *     transitions: {
	 *         layout: {
	 *             name: 'foo',
	 *             duration: 500
	 *         }
	 *     }
	 * 
	 * Otherwise the name will be set automatically, for example:
	 * 
	 *     transition.name = this.getId() + '-' + key
	 * 
	 * Transition names (whether explicitly given or not) are prefixed by component ID
	 * to prevent transitions with the same name but on a different component from
	 * cancelling each other out.
	 * 
	 * However, transitions with the same name on the same component will still cancel
	 * each other out, if created via createTransition on the same selection
	 * or with no selection provided.
	 * 
	 * `duration`, `ease` and `name` properties of transition objects in this config
	 * are reserved, and will be used to configure a `d3.transition` instance.
	 * However, transition objects may also have other properties that are related to
	 * this transition. For example:
	 * 
	 *     transitions: {
	 *         select: {
	 *             duration: 500,
	 *             ease: 'cubicInOut',
	 *             targetScale: 1.1
	 *         }
	 *     }
	 * 
	 * The `targetScale` property here won't be consumed by a `d3.transition` instance;
	 * instead a component can make use of it in whichever way it sees fit to animate
	 * the selected element.
	 * 
	 */
	transitions?: any

	/**
	 * The ui or uis to be used on this Component
	 * 
	 * When a ui is configured, CSS class names are added to the element, created
	 * by appending the ui name(s) to each classCls and/or baseCls.
	 * 
	 */
	ui?: string | string[]

	/**
	 * One or more CSS classes to add to the component's primary element. This config
	 * is intended solely for use by the component instantiator (the "user"), not by
	 * derived classes.
	 * 
	 * For example:
	 * 
	 *      items: [{
	 *          xtype: 'button',
	 *          userCls: 'my-button'
	 *      ...
	 *      }]
	 * 
	 */
	userCls?: string | string[]

	/**
	 * This value controls this item's order in a Ext.Container#cfg!weighted
	 * Ext.Container (see cfg!parent).
	 * 
	 * Lower values gravitate towards the start of the container - the top in vertical layouts, the
	 * locale start side in horizontal layouts.
	 * 
	 */
	weight?: number

	/**
	 * The width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	width?: number | string

	/**
	 * The z-index to give this Component when it is rendered.
	 * 
	 * Not valid for cfg-floated Components. The Z ordering of cfg-floated
	 * Components is managed by ordering of the DOM elements.
	 * 
	 */
	zIndex?: number

	/**
	 * Fires after a Component had been added to a Container.
	 * 
	 */
	onAdded?: (me: any, container: any, index: number) => void

	/**
	 * This event fires when `cfg!bottom` changes.
	 */
	onBeforeBottomChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!centered` changes.
	 */
	onBeforeCenteredChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!disabled` changes.
	 */
	onBeforeDisabledChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!docked` changes.
	 */
	onBeforeDockedChange?: (sender: any, value: string, oldValue: string) => void

	/**
	 * This event fires when `cfg!height` changes.
	 */
	onBeforeHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!hidden` changes.
	 */
	onBeforeHiddenChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires before the Component is hidden. Hide may be vetoed by returning `false` from a handler.
	 * 
	 */
	onBeforeHide?: (me: any) => void

	/**
	 * This event fires when `cfg!left` changes.
	 */
	onBeforeLeftChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxHeight` changes.
	 */
	onBeforeMaxHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxWidth` changes.
	 */
	onBeforeMaxWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minHeight` changes.
	 */
	onBeforeMinHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minWidth` changes.
	 */
	onBeforeMinWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!right` changes.
	 */
	onBeforeRightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!scrollable` changes.
	 */
	onBeforeScrollableChange?: (sender: any, value: boolean | string | any, oldValue: boolean | string | any) => void

	/**
	 * Fires before the Component is shown. Show may be vetoed by returning `false` from a handler.
	 * 
	 */
	onBeforeShow?: (me: any) => void

	/**
	 * This event fires when `cfg!top` changes.
	 */
	onBeforeTopChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!width` changes.
	 */
	onBeforeWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires when this Component's focusEl loses focus.
	 * 
	 */
	onBlur?: (me: any, event: any) => void

	/**
	 * This event fires when `cfg!bottom` changes.
	 */
	onBottomChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!centered` changes.
	 */
	onCenteredChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires when the component is destroyed
	 * 
	 */
	onDestroy?: () => void

	/**
	 * This event fires when `cfg!disabled` changes.
	 */
	onDisabledChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!docked` changes.
	 */
	onDockedChange?: (sender: any, value: string, oldValue: string) => void

	/**
	 * Fires when the component is no longer displayed in the DOM.  Listening to this event will
	 * degrade performance not recommend for general use.
	 * 
	 */
	onErased?: (me: any) => void

	/**
	 * Fires when this Component's focusEl receives focus.
	 * 
	 */
	onFocus?: (me: any, event: any) => void

	/**
	 * Fires when focus enters this Component's hierarchy.
	 * 
	 */
	onFocusEnter?: (me: any, event: any) => void

	/**
	 * Fires when focus leaves this Component's hierarchy.
	 * 
	 */
	onFocusLeave?: (me: any, event: any) => void

	/**
	 * Fires whenever a Component with the fullscreen config is instantiated
	 * 
	 */
	onFullscreen?: (me: any) => void

	/**
	 * This event fires when `cfg!height` changes.
	 */
	onHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!hidden` changes.
	 */
	onHiddenChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires whenever the Component is hidden
	 * 
	 */
	onHide?: (me: any) => void

	/**
	 * Fires when the component has been initialized
	 * 
	 */
	onInitialize?: (me: any) => void

	/**
	 * This event fires when `cfg!left` changes.
	 */
	onLeftChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxHeight` changes.
	 */
	onMaxHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxWidth` changes.
	 */
	onMaxWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minHeight` changes.
	 */
	onMinHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minWidth` changes.
	 */
	onMinWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires when a component si moved within its Container.
	 * 
	 */
	onMoved?: (me: any, container: any, toIndex: number, fromIndex: number) => void

	/**
	 * Fires whenever this Element actually becomes visible (painted) on the screen. This is useful when you need to
	 * perform 'read' operations on the DOM element, i.e: calculating natural sizes and positioning.
	 * 
	 * __Note:__ This event is not available to be used with event delegation. Instead `painted` only fires if you explicitly
	 * add at least one listener to it, for performance reasons.
	 * 
	 */
	onPainted?: (element: any) => void

	/**
	 * Fires whenever there is a change in the positioned status of a component
	 * 
	 */
	onPositionedChange?: (me: any, positioned: boolean) => void

	/**
	 * Fires when a component is removed from a Container
	 * 
	 */
	onRemoved?: (me: any, container: any, index: number) => void

	/**
	 * Fires *asynchronously* after a browser layout caused by a component resize. This may be triggered for any or
	 * several of the following reasons:
	 *    - Programmatic changes to cfg-width or cfg-height configs.
	 *    - Setting the cfg-flex config when the owning layout is Ext.layout.Box.
	 *    - Setting cfg-minHeight, cfg-maxHeight, cfg-minWidth or cfg-maxWidth.
	 *    - Changing device orientation.
	 *    - Changing the browser viewport size.
	 *    - Any resize caused by browser layout recalculation which may be caused by content size changes
	 *      or application of default browser layout rules.
	 * 
	 */
	onResize?: (component: any, width: string | number, height: string | number, oldWidth: string | number, oldHeight: string | number) => void

	/**
	 * This event fires when `cfg!right` changes.
	 */
	onRightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires after scene size has changed.
	 * Note that resizing the Canvas will reset its context, e.g.
	 * `lineWidth` will be reset to `1`, `fillStyle` to `#000000`, and so on,
	 * including transformations.
	 * 
	 */
	onSceneResize?: (component: any, canvas: any, size: any) => void

	/**
	 * This event fires when `cfg!scrollable` changes.
	 */
	onScrollableChange?: (sender: any, value: boolean | string | any, oldValue: boolean | string | any) => void

	/**
	 * Fires whenever the Component is shown
	 * 
	 */
	onShow?: (me: any) => void

	/**
	 * This event fires when `cfg!top` changes.
	 */
	onTopChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!width` changes.
	 */
	onWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void
}

/**
 * 
 * The 'D3_HeatMap' component is used for visualizing matrices
 * where the individual values are represented as colors.
 * The component makes use of two Ext.d3.axis.Data axes (one for each
 * dimension of the matrix) and a single Ext.d3.axis.Color axis
 * to encode the values.
 * 
 *     @example packages=[d3,reactor]
 *     import React, { Component } from 'react'
 *     import { Container }  from '@extjs/ext-react';
 *     import { D3_HeatMap } from '@extjs/ext-react-d3';
 * 
 *     export default class MyExample extends Component {
 * 
 *         store = new Ext.data.Store({
 *             fields: [
 *                 {name: 'date', type: 'date', dateFormat: 'Y-m-d'},
 *                 'bucket',
 *                 'count'
 *             ],
 *             data: [
 *                 { "date": "2012-07-20", "bucket": 800, "count": 119 },
 *                 { "date": "2012-07-20", "bucket": 900, "count": 123 },
 *                 { "date": "2012-07-20", "bucket": 1000, "count": 173 },
 *                 { "date": "2012-07-20", "bucket": 1100, "count": 226 },
 *                 { "date": "2012-07-20", "bucket": 1200, "count": 284 },
 * 
 *                 { "date": "2012-07-21", "bucket": 800, "count": 123 },
 *                 { "date": "2012-07-21", "bucket": 900, "count": 165 },
 *                 { "date": "2012-07-21", "bucket": 1000, "count": 237 },
 *                 { "date": "2012-07-21", "bucket": 1100, "count": 278 },
 *                 { "date": "2012-07-21", "bucket": 1200, "count": 338 },
 * 
 *                 { "date": "2012-07-22", "bucket": 900, "count": 154 },
 *                 { "date": "2012-07-22", "bucket": 1000, "count": 241 },
 *                 { "date": "2012-07-22", "bucket": 1100, "count": 246 },
 *                 { "date": "2012-07-22", "bucket": 1200, "count": 300 },
 *                 { "date": "2012-07-22", "bucket": 1300, "count": 305 },
 * 
 *                 { "date": "2012-07-23", "bucket": 800, "count": 120 },
 *                 { "date": "2012-07-23", "bucket": 900, "count": 156 },
 *                 { "date": "2012-07-23", "bucket": 1000, "count": 209 },
 *                 { "date": "2012-07-23", "bucket": 1100, "count": 267 },
 *                 { "date": "2012-07-23", "bucket": 1200, "count": 299 },
 *                 { "date": "2012-07-23", "bucket": 1300, "count": 316 },
 * 
 *                 { "date": "2012-07-24", "bucket": 800, "count": 105 },
 *                 { "date": "2012-07-24", "bucket": 900, "count": 156 },
 *                 { "date": "2012-07-24", "bucket": 1000, "count": 220 },
 *                 { "date": "2012-07-24", "bucket": 1100, "count": 255 },
 *                 { "date": "2012-07-24", "bucket": 1200, "count": 308 },
 * 
 *                 { "date": "2012-07-25", "bucket": 800, "count": 104 },
 *                 { "date": "2012-07-25", "bucket": 900, "count": 191 },
 *                 { "date": "2012-07-25", "bucket": 1000, "count": 201 },
 *                 { "date": "2012-07-25", "bucket": 1100, "count": 238 },
 *                 { "date": "2012-07-25", "bucket": 1200, "count": 223 },
 * 
 *                 { "date": "2012-07-26", "bucket": 1300, "count": 132 },
 *                 { "date": "2012-07-26", "bucket": 1400, "count": 117 },
 *                 { "date": "2012-07-26", "bucket": 1500, "count": 124 },
 *                 { "date": "2012-07-26", "bucket": 1600, "count": 154 },
 *                 { "date": "2012-07-26", "bucket": 1700, "count": 167 }
 *             ]
 *         });
 * 
 *         render() {
 *             return (
 *                 <Container layout="fit">
 *                     <D3_HeatMap
 *                         store={this.store}
 *                         xAxis={{
 *                             axis: {
 *                                 ticks: 'd3.timeDay',
 *                                 tickFormat: "d3.timeFormat('%b %d')",
 *                                 orient: 'bottom'
 *                             },
 *                             scale: {
 *                                 type: 'time'
 *                             },
 *                             field: 'date',
 *                             step: 24 * 60 * 60 * 1000
 *                         }}
 *                         yAxis={{
 *                             axis: {
 *                                 orient: 'left'
 *                             },
 *                             scale: {
 *                                 type: 'linear'
 *                             },
 *                             title: {
 *                                 text: 'Total'
 *                             },
 * 
 *                             field: 'bucket',
 *                             step: 100
 *                         }}
 *                         colorAxis={{
 *                             scale: {
 *                                 type: 'linear',
 *                                 range: ['white', 'orange']
 *                             },
 *                             field: 'count',
 *                             minimum: 0
 *                         }}
 *                         tiles={{
 *                                 attr: {
 *                                 'stroke': 'black',
 *                                 'stroke-width': 1
 *                             }
 *                         }}
 *                     />
 *                 </Container>
 *             )
 *         }
 *     }
 * 
 */
declare class D3_HeatMap extends React.Component<D3_HeatMapProps, any> { }
export interface D3_HeatMapProps extends FlexibleProps {

	/**
	 * An object containing ARIA attributes to be set
	 * on this Component's ARIA element. Use this to set the attributes that cannot be
	 * determined by the Component's state, such as `aria-live`, `aria-flowto`, etc.
	 * 
	 * **Note** that this config is only meaningful at the Component rendering time,
	 * and setting it after that will do nothing.
	 * 
	 */
	ariaAttributes?: any

	/**
	 * DOM selector for a child element that is to be used
	 * as description for this Component, set in `aria-describedby` attribute.
	 * The selector works the same way as ariaLabelledBy.
	 * 
	 */
	ariaDescribedBy?: string

	/**
	 * ARIA label for this Component. It is best to use
	 * ariaLabelledBy option instead, because screen readers prefer
	 * `aria-labelledby` attribute to `aria-label`. ariaLabel and
	 * ariaLabelledBy config options are mutually exclusive.
	 * 
	 */
	ariaLabel?: string

	/**
	 * DOM selector for a child element that is to be used
	 * as label for this Component, set in `aria-labelledby` attribute.
	 * If the selector is by `#id`, the label element can be any existing element,
	 * not necessarily a child of the main Component element.
	 * 
	 * ariaLabelledBy and ariaLabel config options are
	 * mutually exclusive, and `ariaLabelledBy` has the higher precedence.
	 * 
	 */
	ariaLabelledBy?: string

	/**
	 * If `true`, then, when showBy or alignTo fallback on
	 * constraint violation only takes place along the major align axis.
	 * 
	 * That is, if alignment `"l-r"` is being used, and `axisLock: true` is used, then if constraints
	 * fail, only fallback to `"r-l"` is considered.
	 * 
	 */
	axisLock?: boolean

	/**
	 * 
	 * Enables or disables bordering on this component.
	 * The following values are accepted:
	 * 
	 * - `null` or `true (default): Do nothing and allow the border to be specified by the theme.
	 * - `false`: suppress the default border provided by the theme.
	 * 
	 * Please note that enabling bordering via this config will not add a `border-color`
	 * or `border-style` CSS property to the component; you provide the `border-color`
	 * and `border-style` via CSS rule or style configuration
	 * (if not already provide by the theme).
	 * 
	 */
	border?: boolean

	/**
	 * The absolute bottom position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	bottom?: number | string

	/**
	 * Configure this as `true` to have this Component centered within its Container.
	 * Setting this value to `true` will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	centered?: boolean

	/**
	 * If the scene elements that go outside the scene and into the padding area
	 * should be clipped.
	 * Note: stock D3 components are not designed to work with this config set to `true`.
	 * 
	 */
	clipScene?: boolean

	/**
	 * The CSS class to add to this widget's element, in
	 * addition to the baseCls. In many cases, this property will be specified
	 * by the derived widget class. See userCls for adding additional CSS
	 * classes to widget instances (such as items in a Ext.Container).
	 * 
	 */
	cls?: string | string[]

	/**
	 * The axis that corresponds to the values of the data matrix.
	 * 
	 */
	colorAxis?: any

	/**
	 * The CSS class used by a subclass of the D3 Component.
	 * Normally, the lower-cased name of a subclass.
	 * 
	 */
	componentCls?: string

	/**
	 * The configured element will automatically be
	 * added as the content of this component. When you pass a string, we expect it to be an element id.
	 * If the content element is hidden, we will automatically show it.
	 * 
	 */
	contentEl?: any | HTMLElement | string

	/**
	 * The initial set of data to apply to the `tpl` to
	 * update the content area of the Component.
	 * 
	 */
	data?: any

	/**
	 * Whether or not this component is disabled
	 * 
	 */
	disabled?: boolean

	/**
	 * The dock position of this component in its container. Can be `left`, `top`, `right` or `bottom`.
	 * 
	 * __Notes__
	 * 
	 * You must use a HTML5 doctype for docked `bottom` to work. To do this, simply add the following code to the HTML file:
	 * 
	 *     <!doctype html>
	 * 
	 * So your index.html file should look a little like this:
	 * 
	 *     <!doctype html>
	 *     <html>
	 *         <head>
	 *             <title>MY application title</title>
	 *             ...
	 * 
	 */
	docked?: string

	/**
	 * Configuration options to make this Component draggable
	 * 
	 */
	draggable?: any

	/**
	 * CSS class that will be added to focused
	 * component's focusClsEl, and removed when component blurs.
	 * 
	 */
	focusCls?: string

	/**
	 * Force the component to take up 100% width and height available, by adding it
	 * to Ext.Viewport.
	 * 
	 */
	fullscreen?: boolean

	/**
	 * The height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	height?: number | string

	/**
	 * Whether or not this Component is hidden (its CSS `display` property is set to `none`).
	 * 
	 * Defaults to `true` for floated Components.
	 * 
	 */
	hidden?: boolean

	/**
	 * Animation effect to apply when the Component is being hidden.  Typically you want to use an
	 * outbound animation type such as 'fadeOut' or 'slideOut'. For more animations, check the Ext.fx.Animation#type config.
	 * 
	 */
	hideAnimation?: string | any

	/**
	 * When using a cfg!modal Component, setting this to `true`
	 * will hide the modal mask and the Container when the mask is tapped on.
	 * 
	 */
	hideOnMaskTap?: boolean

	/**
	 * Optional HTML content to render inside this Component, or a reference
	 * to an existing element on the page.
	 * 
	 */
	html?: string | any | HTMLElement

	/**
	 * The list of interaction configs for this D3 component.
	 * D3 package interactions are very similar to native D3 behaviors.
	 * However, D3 behaviors, as well as event system, is incompatible
	 * with ExtJS event system. D3 package interactions may also support
	 * certain features that D3 behaviors lack, like like kinetic scrolling,
	 * elastic borders and scroll indicators (see the Ext.d3.interaction.PanZoom
	 * interaction for more information).
	 * 
	 */
	interactions?: any[]

	/**
	 * An object containing handlers for keyboard events. The property names of this
	 * object are the key name and any modifiers. The values of the properties are the
	 * descriptors of how to handle each event.
	 * 
	 * The handler descriptor can be simply the handler function (either the
	 * literal function or the method name), or it can be an object with these
	 * properties:
	 * 
	 *  - `handler`: The function or its name to call to handle the event.
	 *  - `scope`: The this pointer context (can be "this" or "controller").
	 *  - `event`: An optional override of the key event to which to listen.
	 * 
	 * **Important:** Calls to `setKeyMap` do not replace the entire `keyMap` but
	 * instead update the provided mappings. That is, unless `null` is passed as the
	 * value of the `keyMap` which will clear the `keyMap` of all entries.
	 * 
	 */
	keyMap?: any

	/**
	 * Enables or disables processing keys in the `keyMap`. This value starts as
	 * `null` and if it is `null` when `initKeyMap` is called, it will automatically
	 * be set to `true`. Since `initKeyMap` is called by `Ext.Component` at the
	 * proper time, this is not something application code normally handles.
	 * 
	 */
	keyMapEnabled?: boolean

	/**
	 * This config controls the appearance of the heatmap labels.
	 * 
	 */
	labels?: any | boolean

	/**
	 * The absolute left position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	left?: number | string

	/**
	 * The legend for tiles' colors.
	 * See the Ext.d3.legend.Color documentation for configuration options.
	 * 
	 */
	legend?: any

	/**
	 * 
	 * A config object containing one or more event handlers to be added to this object during initialization. This
	 * should be a valid listeners config object as specified in the
	 * addListener example for attaching
	 * multiple handlers at once.
	 * 
	 * **DOM events from Ext JS Ext.Component**
	 * 
	 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
	 * only done when extra value can be added. For example the DataView's **`itemclick`** event passing the node clicked on. To access DOM events directly from a
	 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
	 * DOM listener to:
	 * 
	 *     new Ext.panel.Panel({
	 *         width: 400,
	 *         height: 200,
	 *         dockedItems: [{
	 *             xtype: 'toolbar'
	 *         }],
	 *         listeners: {
	 *             click: {
	 *                 element: 'el', //bind to the underlying el property on the panel
	 *                 fn: function(){ console.log('click el'); }
	 *             },
	 *             dblclick: {
	 *                 element: 'body', //bind to the underlying body property on the panel
	 *                 fn: function(){ console.log('dblclick body'); }
	 *             }
	 *         }
	 *     });
	 * 
	 */
	listeners?: any

	/**
	 * The margin to use on this Component. Can be specified as a number (in which case
	 * all edges get the same margin) or a CSS string like '5 10 10 10'
	 * 
	 */
	margin?: number | string

	/**
	 * The maximum height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * Note that this config will not apply if the Component is 'positioned' (absolutely positioned or centered)
	 * 
	 */
	maxHeight?: number | string

	/**
	 * The maximum width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * Note that this config will not apply if the Component is 'positioned' (absolutely positioned or centered)
	 * 
	 */
	maxWidth?: number | string

	/**
	 * The minimum height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	minHeight?: number | string

	/**
	 * The minimum width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	minWidth?: number | string

	/**
	 * `true` to make this Component modal. This will create a mask underneath the Component
	 * that covers its parent and does not allow the user to interact with any other Components until this
	 * Component is dismissed.
	 * 
	 */
	modal?: boolean

	/**
	 * Name for the widget to be used with Ext.Container#lookupName et al.
	 * 
	 */
	name?: string

	/**
	 * The padding of the scene.
	 * See Ext.util.Format#parseBox for syntax details,
	 * if using a string for this config.
	 * 
	 */
	padding?: any | string | number

	/**
	 * An object or array of objects that will provide custom functionality for this
	 * component. If a string is provided or a string is one of the elements of the
	 * array, that string is treated as the `type` alias. For example, "listpaging"
	 * is the type alias for `Ext.plugin.ListPaging`. The full alias includes the
	 * "plugin." prefix (i.e., 'plugin.listpaging').
	 * 
	 * Plugins should derive from `Ext.plugin.Abstract` but this is not required. The
	 * only requirement for a valid plugin is that it contain an `init()` method that
	 * accepts a reference to the owning component.
	 * 
	 * When a component is created, if any plugins are available, the component will
	 * call the `init` method on each plugin,
	 * passing a reference to itself. Each plugin can then call methods or respond to
	 * events on the component as needed to provide its functionality.
	 * 
	 * ## Example code
	 * 
	 * A plugin by alias:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: 'listpaging'
	 *      });
	 * 
	 * Multiple plugins by alias:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: ['listpaging', 'pullrefresh']
	 *      });
	 * 
	 * Single plugin by class name with config options:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: {
	 *              type: 'listpaging',
	 *              autoPaging: true
	 *          }
	 *      });
	 * 
	 * Multiple plugins by type and class name with config options:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: [{
	 *              xclass: 'Ext.plugin.PullRefresh',
	 *              pullRefreshText: 'Pull to refresh...'
	 *          }, {
	 *              type: 'listpaging',
	 *              autoPaging: true
	 *          }]
	 *      });
	 * 
	 */
	plugins?: any | string | any[] | string[]

	/**
	 * A model instance which updates the Component's html based on it's tpl. Similar to the data
	 * configuration, but tied to to a record to make allow dynamic updates.  This must be a model
	 * instance and not a configuration of one.
	 * 
	 */
	record?: any

	/**
	 * Optional element to render this Component to.
	 * Not required if this component is an item of a Container of a Container.
	 * 
	 */
	renderTo?: any

	/**
	 * The absolute right position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	right?: number | string

	/**
	 * Configuration options to make this Component scrollable. Acceptable values are:
	 * 
	 * - `true` to enable auto scrolling.
	 * - `false` (or `null`) to disable scrolling - this is the default.
	 * - `x` or `horizontal` to enable horizontal scrolling only
	 * - `y` or `vertical` to enable vertical scrolling only
	 * 
	 * Also accepts a configuration object for a `Ext.scroll.Scroller` if
	 * if advanced configuration is needed.
	 * 
	 * The getter for this config returns the Ext.scroll.Scroller
	 * instance.  You can use the Scroller API to read or manipulate the scroll position:
	 * 
	 *     // scrolls the component to 5 on the x axis and 10 on the y axis
	 *     component.getScrollable().scrollTo(5, 10);
	 * 
	 */
	scrollable?: boolean | string | any

	/**
	 * Animation effect to apply when the Component is being shown.  Typically you want to use an
	 * inbound animation type such as 'fadeIn' or 'slideIn'. For more animations, check the Ext.fx.Animation#type config.
	 * 
	 */
	showAnimation?: string | any

	/**
	 * Whether or not the component got its first size.
	 * Can be used in the `sceneresize` event handler to do user-defined setup on first
	 * resize, for example:
	 * 
	 *     listeners: {
	 *         sceneresize: function (component, scene, rect) {
	 *             if (!component.size) {
	 *                 // set things up
	 *             } else {
	 *                 // handle resize
	 *             }
	 *         }
	 *     }
	 * 
	 */
	size?: any

	/**
	 * The store with data to render.
	 * 
	 */
	store?: any

	/**
	 * Additional CSS styles that will be rendered into an inline style attribute when
	 * the widget is rendered.
	 * 
	 * You can pass either a string syntax:
	 * 
	 *     style: 'background:red'
	 * 
	 * Or by using an object:
	 * 
	 *     style: {
	 *         background: 'red'
	 *     }
	 * 
	 * When using the object syntax, you can define CSS Properties by using a string:
	 * 
	 *     style: {
	 *         'border-left': '1px solid red'
	 *     }
	 * 
	 * Although the object syntax is much easier to read, we suggest you to use the
	 * string syntax for better performance.
	 * 
	 */
	style?: string | any

	/**
	 * DOM tabIndex attribute for this component's focusEl.
	 * 
	 */
	tabIndex?: number

	/**
	 * This config controls the appearance of the heatmap tiles.
	 * 
	 */
	tiles?: any

	/**
	 * The Ext.tip.ToolTip for this component.
	 * 
	 *     <Button text="Basic Tip">
	 *         <ToolTip>A simple tooltip</ToolTip>
	 *     </Button>
	 * 
	 */
	tooltip?: any

	/**
	 * The absolute top position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	top?: number | string

	/**
	 * 
	 * Emulates the behavior of the CSS [touch-action](https://www.w3.org/TR/pointerevents/#the-touch-action-css-property)
	 * property in a cross-browser compatible manner.
	 * 
	 * Keys in this object are touch action names, and values are `false` to disable
	 * a touch action or `true` to enable it.  Accepted keys are:
	 * 
	 * - `panX`
	 * - `panY`
	 * - `pinchZoom`
	 * - `doubleTapZoom`
	 * 
	 * All touch actions are enabled (`true`) by default, so it is usually only necessary
	 * to specify which touch actions to disable.  For example, the following disables
	 * only horizontal scrolling and pinch-to-zoom on the component's main element:
	 * 
	 *     touchAction: {
	 *         panX: false,
	 *         pinchZoom: false
	 *     }
	 * 
	 * Touch actions can be specified on reference elements using the reference element
	 * name, for example:
	 * 
	 *     // disables horizontal scrolling on the main element, and double-tap-zoom
	 *     // on the child element named "body"
	 *     touchAction: {
	 *         panY: false
	 *         body: {
	 *             doubleTapZoom: false
	 *         }
	 *     }
	 * 
	 * The primary motivation for setting the touch-action of an element is to prevent
	 * the browser's default handling of a gesture such as pinch-to-zoom, or
	 * drag-to-scroll, so that the application can implement its own handling of that
	 * gesture on the element.  Suppose, for example, a component has a custom drag
	 * handler on its element and wishes to prevent horizontal scrolling of its container
	 * while it is being dragged:
	 * 
	 *     Ext.create('Ext.Widget', {
	 *         touchAction: {
	 *             panX: false
	 *         },
	 *         listeners: {
	 *             drag: function(e) {
	 *                 // implement drag logic
	 *             }
	 *         }
	 *     });
	 * 
	 */
	touchAction?: any

	/**
	 * 
	 * A string, array of strings, or a function that returns JSX.
	 * 
	 *    tpl = data => <div>{data.first_name} {data.last_name}</div>
	 * 
	 * __Note__
	 * The data configuration _must_ be set for any content to be shown in the component when using this configuration.
	 * 
	 */
	tpl?: Function | string | string[]

	/**
	 * The Ext.(X)Template method to use when updating the content area of the Component.
	 * 
	 * Valid modes are:
	 * 
	 * - append
	 * - insertAfter
	 * - insertBefore
	 * - insertFirst
	 * - overwrite
	 * 
	 */
	tplWriteMode?: string

	/**
	 * A map of transition configs. For example:
	 * 
	 *     transitions: {
	 *         select: {
	 *             duration: 500,
	 *             ease: 'cubicInOut'
	 *         },
	 *         zoom: {
	 *             name: 'zoom',
	 *             duration: 1000
	 *         },
	 *         ...
	 *     }
	 * 
	 * A class would define the defaults for its transitions, and a user only needs
	 * to set the `transitions` config of an instance to disable a transition, e.g.:
	 * 
	 *     transitions: {
	 *         // transitions are enabled by default, `true` should never be used here
	 *         select: false
	 *     }
	 * 
	 * or alter its config:
	 * 
	 *     transitions: {
	 *         select: {
	 *             // the `duration` stays the same,
	 *             // only the easing function is altered
	 *             ease: 'bounceOut'
	 *         }
	 *     }
	 * 
	 * The transitions defined this way are merely configs. To create an actual transition
	 * from one of these configs, use the createTransition method. For example:
	 * 
	 *     this.createTransition('select')
	 * 
	 * A transition object can optionally specify a name, if it's different from
	 * the key in the `transitions` config. For example:
	 * 
	 *     transitions: {
	 *         layout: {
	 *             name: 'foo',
	 *             duration: 500
	 *         }
	 *     }
	 * 
	 * Otherwise the name will be set automatically, for example:
	 * 
	 *     transition.name = this.getId() + '-' + key
	 * 
	 * Transition names (whether explicitly given or not) are prefixed by component ID
	 * to prevent transitions with the same name but on a different component from
	 * cancelling each other out.
	 * 
	 * However, transitions with the same name on the same component will still cancel
	 * each other out, if created via createTransition on the same selection
	 * or with no selection provided.
	 * 
	 * `duration`, `ease` and `name` properties of transition objects in this config
	 * are reserved, and will be used to configure a `d3.transition` instance.
	 * However, transition objects may also have other properties that are related to
	 * this transition. For example:
	 * 
	 *     transitions: {
	 *         select: {
	 *             duration: 500,
	 *             ease: 'cubicInOut',
	 *             targetScale: 1.1
	 *         }
	 *     }
	 * 
	 * The `targetScale` property here won't be consumed by a `d3.transition` instance;
	 * instead a component can make use of it in whichever way it sees fit to animate
	 * the selected element.
	 * 
	 */
	transitions?: any

	/**
	 * The ui or uis to be used on this Component
	 * 
	 * When a ui is configured, CSS class names are added to the element, created
	 * by appending the ui name(s) to each classCls and/or baseCls.
	 * 
	 */
	ui?: string | string[]

	/**
	 * One or more CSS classes to add to the component's primary element. This config
	 * is intended solely for use by the component instantiator (the "user"), not by
	 * derived classes.
	 * 
	 * For example:
	 * 
	 *      items: [{
	 *          xtype: 'button',
	 *          userCls: 'my-button'
	 *      ...
	 *      }]
	 * 
	 */
	userCls?: string | string[]

	/**
	 * This value controls this item's order in a Ext.Container#cfg!weighted
	 * Ext.Container (see cfg!parent).
	 * 
	 * Lower values gravitate towards the start of the container - the top in vertical layouts, the
	 * locale start side in horizontal layouts.
	 * 
	 */
	weight?: number

	/**
	 * The width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	width?: number | string

	/**
	 * The axis that corresponds to the columns of the data matrix.
	 * 
	 */
	xAxis?: any

	/**
	 * The axis that corresponds to the rows of the data matrix.
	 * 
	 */
	yAxis?: any

	/**
	 * The z-index to give this Component when it is rendered.
	 * 
	 * Not valid for cfg-floated Components. The Z ordering of cfg-floated
	 * Components is managed by ordering of the DOM elements.
	 * 
	 */
	zIndex?: number

	/**
	 * Fires after a Component had been added to a Container.
	 * 
	 */
	onAdded?: (me: any, container: any, index: number) => void

	/**
	 * This event fires when `cfg!bottom` changes.
	 */
	onBeforeBottomChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!centered` changes.
	 */
	onBeforeCenteredChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!disabled` changes.
	 */
	onBeforeDisabledChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!docked` changes.
	 */
	onBeforeDockedChange?: (sender: any, value: string, oldValue: string) => void

	/**
	 * This event fires when `cfg!height` changes.
	 */
	onBeforeHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!hidden` changes.
	 */
	onBeforeHiddenChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires before the Component is hidden. Hide may be vetoed by returning `false` from a handler.
	 * 
	 */
	onBeforeHide?: (me: any) => void

	/**
	 * This event fires when `cfg!left` changes.
	 */
	onBeforeLeftChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxHeight` changes.
	 */
	onBeforeMaxHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxWidth` changes.
	 */
	onBeforeMaxWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minHeight` changes.
	 */
	onBeforeMinHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minWidth` changes.
	 */
	onBeforeMinWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!right` changes.
	 */
	onBeforeRightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!scrollable` changes.
	 */
	onBeforeScrollableChange?: (sender: any, value: boolean | string | any, oldValue: boolean | string | any) => void

	/**
	 * Fires before the Component is shown. Show may be vetoed by returning `false` from a handler.
	 * 
	 */
	onBeforeShow?: (me: any) => void

	/**
	 * This event fires when `cfg!top` changes.
	 */
	onBeforeTopChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!width` changes.
	 */
	onBeforeWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires when this Component's focusEl loses focus.
	 * 
	 */
	onBlur?: (me: any, event: any) => void

	/**
	 * This event fires when `cfg!bottom` changes.
	 */
	onBottomChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!centered` changes.
	 */
	onCenteredChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires when the component is destroyed
	 * 
	 */
	onDestroy?: () => void

	/**
	 * This event fires when `cfg!disabled` changes.
	 */
	onDisabledChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!docked` changes.
	 */
	onDockedChange?: (sender: any, value: string, oldValue: string) => void

	/**
	 * Fires when the component is no longer displayed in the DOM.  Listening to this event will
	 * degrade performance not recommend for general use.
	 * 
	 */
	onErased?: (me: any) => void

	/**
	 * Fires when this Component's focusEl receives focus.
	 * 
	 */
	onFocus?: (me: any, event: any) => void

	/**
	 * Fires when focus enters this Component's hierarchy.
	 * 
	 */
	onFocusEnter?: (me: any, event: any) => void

	/**
	 * Fires when focus leaves this Component's hierarchy.
	 * 
	 */
	onFocusLeave?: (me: any, event: any) => void

	/**
	 * Fires whenever a Component with the fullscreen config is instantiated
	 * 
	 */
	onFullscreen?: (me: any) => void

	/**
	 * This event fires when `cfg!height` changes.
	 */
	onHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!hidden` changes.
	 */
	onHiddenChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires whenever the Component is hidden
	 * 
	 */
	onHide?: (me: any) => void

	/**
	 * Fires when the component has been initialized
	 * 
	 */
	onInitialize?: (me: any) => void

	/**
	 * This event fires when `cfg!left` changes.
	 */
	onLeftChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxHeight` changes.
	 */
	onMaxHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxWidth` changes.
	 */
	onMaxWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minHeight` changes.
	 */
	onMinHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minWidth` changes.
	 */
	onMinWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires when a component si moved within its Container.
	 * 
	 */
	onMoved?: (me: any, container: any, toIndex: number, fromIndex: number) => void

	/**
	 * Fires whenever this Element actually becomes visible (painted) on the screen. This is useful when you need to
	 * perform 'read' operations on the DOM element, i.e: calculating natural sizes and positioning.
	 * 
	 * __Note:__ This event is not available to be used with event delegation. Instead `painted` only fires if you explicitly
	 * add at least one listener to it, for performance reasons.
	 * 
	 */
	onPainted?: (element: any) => void

	/**
	 * Fires whenever there is a change in the positioned status of a component
	 * 
	 */
	onPositionedChange?: (me: any, positioned: boolean) => void

	/**
	 * Fires when a component is removed from a Container
	 * 
	 */
	onRemoved?: (me: any, container: any, index: number) => void

	/**
	 * Fires *asynchronously* after a browser layout caused by a component resize. This may be triggered for any or
	 * several of the following reasons:
	 *    - Programmatic changes to cfg-width or cfg-height configs.
	 *    - Setting the cfg-flex config when the owning layout is Ext.layout.Box.
	 *    - Setting cfg-minHeight, cfg-maxHeight, cfg-minWidth or cfg-maxWidth.
	 *    - Changing device orientation.
	 *    - Changing the browser viewport size.
	 *    - Any resize caused by browser layout recalculation which may be caused by content size changes
	 *      or application of default browser layout rules.
	 * 
	 */
	onResize?: (component: any, width: string | number, height: string | number, oldWidth: string | number, oldHeight: string | number) => void

	/**
	 * This event fires when `cfg!right` changes.
	 */
	onRightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires after scene size has changed.
	 * Notes: the scene is a 'g' element, so it cannot actually have a size.
	 * The size reported is the size the drawing is supposed to fit in.
	 * 
	 */
	onSceneResize?: (component: any, scene: any, size: any) => void

	/**
	 * Fires once after the scene has been created.
	 * Note that at this time the component doesn't have a size yet.
	 * 
	 */
	onSceneSetup?: (component: any, scene: any) => void

	/**
	 * This event fires when `cfg!scrollable` changes.
	 */
	onScrollableChange?: (sender: any, value: boolean | string | any, oldValue: boolean | string | any) => void

	/**
	 * Fires whenever the Component is shown
	 * 
	 */
	onShow?: (me: any) => void

	/**
	 * This event fires when `cfg!top` changes.
	 */
	onTopChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!width` changes.
	 */
	onWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void
}

/**
 * 
 * The 'd3-pack' component uses D3's
 * [Pack Layout](https://github.com/d3/d3-hierarchy/#pack)
 * to visualize hierarchical data as a enclosure diagram.
 * The size of each leaf node’s circle reveals a quantitative dimension
 * of each data point. The enclosing circles show the approximate cumulative size
 * of each subtree.
 * 
 * The pack additionally layout populates the `r` attribute on each node, where `r` is the
 * computed node radius.
 * 
 *     @example packages=[d3,reactor]
 *     import React, { Component } from 'react'
 *     import { Container }  from '@extjs/ext-react';
 *     import { D3_Pack } from '@extjs/ext-react-d3';
 * 
 *     export default class MyExample extends Component {
 * 
 *         store = Ext.create('Ext.data.TreeStore', {
 *               data: [{
 *                   "text": "DC",
 *                   "children": [{
 *                       "text": "Flash",
 *                       "children": [{
 *                           "text": "Flashpoint"
 *                       }]
 *                   },
 *                       {
 *                           "text": "Green Lantern",
 *                           "children": [{
 *                               "text": "Rebirth"
 *                           },
 *                               {
 *                                   "text": "Sinestro Corps War"
 *                               }
 *                           ]
 *                       },
 *                       {
 *                           "text": "Batman",
 *                           "children": [{
 *                               "text": "Hush"
 *                           },
 *                               {
 *                                   "text": "The Long Halloween"
 *                               },
 *                               {
 *                                   "text": "Batman and Robin"
 *                               },
 *                               {
 *                                   "text": "The Killing Joke"
 *                               }
 *                           ]
 *                       }
 *                   ]
 *               },
 *                   {
 *                       "text": "Marvel",
 *                       "children": [{
 *                           "text": "All",
 *                           "children": [{
 *                               "text": "Infinity War"
 *                           },
 *                               {
 *                                   "text": "Infinity Gauntlet"
 *                               },
 *                               {
 *                                   "text": "Avengers Disassembled"
 *                               }
 *                           ]
 *                       },
 *                           {
 *                               "text": "Spiderman",
 *                               "children": [{
 *                                   "text": "Ultimate Spiderman"
 *                               }]
 *                           },
 *                           {
 *                               "text": "Vision",
 *                               "children": [{
 *                                   "text": "The Vision"
 *                               }]
 *                           },
 *                           {
 *                               "text": "X-Men",
 *                               "children": [{
 *                                   "text": "Gifted"
 *                               },
 *                                   {
 *                                       "text": "Dark Phoenix Saga"
 *                                   },
 *                                   {
 *                                       "text": "Unstoppable"
 *                                   }
 *                               ]
 *                           }
 *                       ]
 *                   }
 *               ]
 *           });
 * 
 *       render() {
 *           return (
 *               <Container layout="fit">
 *                   <D3_Pack
 *                       store={this.store}
 *                       tooltip={{
 *                           renderer: function(component, tooltip, node) {
 *                                 var record = node.data;
 *                                 tooltip.setHtml(record.get('text'));
 *                             }
 *                       }}
 *                   />
 *               </Container>
 *           )
 *       }
 *     }
 * 
 */
declare class D3_Pack extends React.Component<D3_PackProps, any> { }
export interface D3_PackProps extends FlexibleProps {

	/**
	 * An object containing ARIA attributes to be set
	 * on this Component's ARIA element. Use this to set the attributes that cannot be
	 * determined by the Component's state, such as `aria-live`, `aria-flowto`, etc.
	 * 
	 * **Note** that this config is only meaningful at the Component rendering time,
	 * and setting it after that will do nothing.
	 * 
	 */
	ariaAttributes?: any

	/**
	 * DOM selector for a child element that is to be used
	 * as description for this Component, set in `aria-describedby` attribute.
	 * The selector works the same way as ariaLabelledBy.
	 * 
	 */
	ariaDescribedBy?: string

	/**
	 * ARIA label for this Component. It is best to use
	 * ariaLabelledBy option instead, because screen readers prefer
	 * `aria-labelledby` attribute to `aria-label`. ariaLabel and
	 * ariaLabelledBy config options are mutually exclusive.
	 * 
	 */
	ariaLabel?: string

	/**
	 * DOM selector for a child element that is to be used
	 * as label for this Component, set in `aria-labelledby` attribute.
	 * If the selector is by `#id`, the label element can be any existing element,
	 * not necessarily a child of the main Component element.
	 * 
	 * ariaLabelledBy and ariaLabel config options are
	 * mutually exclusive, and `ariaLabelledBy` has the higher precedence.
	 * 
	 */
	ariaLabelledBy?: string

	/**
	 * If `true`, then, when showBy or alignTo fallback on
	 * constraint violation only takes place along the major align axis.
	 * 
	 * That is, if alignment `"l-r"` is being used, and `axisLock: true` is used, then if constraints
	 * fail, only fallback to `"r-l"` is considered.
	 * 
	 */
	axisLock?: boolean

	/**
	 * 
	 * Enables or disables bordering on this component.
	 * The following values are accepted:
	 * 
	 * - `null` or `true (default): Do nothing and allow the border to be specified by the theme.
	 * - `false`: suppress the default border provided by the theme.
	 * 
	 * Please note that enabling bordering via this config will not add a `border-color`
	 * or `border-style` CSS property to the component; you provide the `border-color`
	 * and `border-style` via CSS rule or style configuration
	 * (if not already provide by the theme).
	 * 
	 */
	border?: boolean

	/**
	 * The absolute bottom position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	bottom?: number | string

	/**
	 * Configure this as `true` to have this Component centered within its Container.
	 * Setting this value to `true` will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	centered?: boolean

	/**
	 * If the scene elements that go outside the scene and into the padding area
	 * should be clipped.
	 * Note: stock D3 components are not designed to work with this config set to `true`.
	 * 
	 */
	clipScene?: boolean

	/**
	 * If `false`, the text will always be visible, whether it fits inside its
	 * container or not.
	 * 
	 */
	clipText?: boolean

	/**
	 * The CSS class to add to this widget's element, in
	 * addition to the baseCls. In many cases, this property will be specified
	 * by the derived widget class. See userCls for adding additional CSS
	 * classes to widget instances (such as items in a Ext.Container).
	 * 
	 */
	cls?: string | string[]

	/**
	 * A Ext.d3.axis.Color config or an instance.
	 * By default (if no 'colorAxis' config is given) all nodes
	 * are assigned a unique color from the `d3.scale.category20c`
	 * scale (until the colors run out, then we start to reuse them)
	 * based on the value of the `name` field.
	 * 
	 */
	colorAxis?: any

	/**
	 * The CSS class used by a subclass of the D3 Component.
	 * Normally, the lower-cased name of a subclass.
	 * 
	 */
	componentCls?: string

	/**
	 * The configured element will automatically be
	 * added as the content of this component. When you pass a string, we expect it to be an element id.
	 * If the content element is hidden, we will automatically show it.
	 * 
	 */
	contentEl?: any | HTMLElement | string

	/**
	 * The initial set of data to apply to the `tpl` to
	 * update the content area of the Component.
	 * 
	 */
	data?: any

	/**
	 * Whether or not this component is disabled
	 * 
	 */
	disabled?: boolean

	/**
	 * The dock position of this component in its container. Can be `left`, `top`, `right` or `bottom`.
	 * 
	 * __Notes__
	 * 
	 * You must use a HTML5 doctype for docked `bottom` to work. To do this, simply add the following code to the HTML file:
	 * 
	 *     <!doctype html>
	 * 
	 * So your index.html file should look a little like this:
	 * 
	 *     <!doctype html>
	 *     <html>
	 *         <head>
	 *             <title>MY application title</title>
	 *             ...
	 * 
	 */
	docked?: string

	/**
	 * Configuration options to make this Component draggable
	 * 
	 */
	draggable?: any

	/**
	 * The expand event(s) to listen for on each node.
	 * The node in question will be expanded, if collapsed,
	 * or collapsed, if expanded.
	 * `false` can be used to prevent listening for the default event.
	 * 
	 */
	expandEventName?: string | string[] | any

	/**
	 * CSS class that will be added to focused
	 * component's focusClsEl, and removed when component blurs.
	 * 
	 */
	focusCls?: string

	/**
	 * Force the component to take up 100% width and height available, by adding it
	 * to Ext.Viewport.
	 * 
	 */
	fullscreen?: boolean

	/**
	 * The height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	height?: number | string

	/**
	 * Whether or not this Component is hidden (its CSS `display` property is set to `none`).
	 * 
	 * Defaults to `true` for floated Components.
	 * 
	 */
	hidden?: boolean

	/**
	 * Animation effect to apply when the Component is being hidden.  Typically you want to use an
	 * outbound animation type such as 'fadeOut' or 'slideOut'. For more animations, check the Ext.fx.Animation#type config.
	 * 
	 */
	hideAnimation?: string | any

	/**
	 * When using a cfg!modal Component, setting this to `true`
	 * will hide the modal mask and the Container when the mask is tapped on.
	 * 
	 */
	hideOnMaskTap?: boolean

	/**
	 * The class name added to all hierarchy components (subclasses).
	 * See also componentCls.
	 * 
	 */
	hierarchyCls?: string

	/**
	 * Optional HTML content to render inside this Component, or a reference
	 * to an existing element on the page.
	 * 
	 */
	html?: string | any | HTMLElement

	/**
	 * The list of interaction configs for this D3 component.
	 * D3 package interactions are very similar to native D3 behaviors.
	 * However, D3 behaviors, as well as event system, is incompatible
	 * with ExtJS event system. D3 package interactions may also support
	 * certain features that D3 behaviors lack, like like kinetic scrolling,
	 * elastic borders and scroll indicators (see the Ext.d3.interaction.PanZoom
	 * interaction for more information).
	 * 
	 */
	interactions?: any[]

	/**
	 * An object containing handlers for keyboard events. The property names of this
	 * object are the key name and any modifiers. The values of the properties are the
	 * descriptors of how to handle each event.
	 * 
	 * The handler descriptor can be simply the handler function (either the
	 * literal function or the method name), or it can be an object with these
	 * properties:
	 * 
	 *  - `handler`: The function or its name to call to handle the event.
	 *  - `scope`: The this pointer context (can be "this" or "controller").
	 *  - `event`: An optional override of the key event to which to listen.
	 * 
	 * **Important:** Calls to `setKeyMap` do not replace the entire `keyMap` but
	 * instead update the provided mappings. That is, unless `null` is passed as the
	 * value of the `keyMap` which will clear the `keyMap` of all entries.
	 * 
	 */
	keyMap?: any

	/**
	 * Enables or disables processing keys in the `keyMap`. This value starts as
	 * `null` and if it is `null` when `initKeyMap` is called, it will automatically
	 * be set to `true`. Since `initKeyMap` is called by `Ext.Component` at the
	 * proper time, this is not something application code normally handles.
	 * 
	 */
	keyMapEnabled?: boolean

	/**
	 * The absolute left position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	left?: number | string

	/**
	 * The [key](https://github.com/d3/d3-selection/#selection_data) function for links.
	 * Returns the 'id' of the link's target Ext.data.TreeModel by default.
	 * 
	 */
	linkKey?: Function

	/**
	 * 
	 * A config object containing one or more event handlers to be added to this object during initialization. This
	 * should be a valid listeners config object as specified in the
	 * addListener example for attaching
	 * multiple handlers at once.
	 * 
	 * **DOM events from Ext JS Ext.Component**
	 * 
	 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
	 * only done when extra value can be added. For example the DataView's **`itemclick`** event passing the node clicked on. To access DOM events directly from a
	 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
	 * DOM listener to:
	 * 
	 *     new Ext.panel.Panel({
	 *         width: 400,
	 *         height: 200,
	 *         dockedItems: [{
	 *             xtype: 'toolbar'
	 *         }],
	 *         listeners: {
	 *             click: {
	 *                 element: 'el', //bind to the underlying el property on the panel
	 *                 fn: function(){ console.log('click el'); }
	 *             },
	 *             dblclick: {
	 *                 element: 'body', //bind to the underlying body property on the panel
	 *                 fn: function(){ console.log('dblclick body'); }
	 *             }
	 *         }
	 *     });
	 * 
	 */
	listeners?: any

	/**
	 * The margin to use on this Component. Can be specified as a number (in which case
	 * all edges get the same margin) or a CSS string like '5 10 10 10'
	 * 
	 */
	margin?: number | string

	/**
	 * The maximum height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * Note that this config will not apply if the Component is 'positioned' (absolutely positioned or centered)
	 * 
	 */
	maxHeight?: number | string

	/**
	 * The maximum width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * Note that this config will not apply if the Component is 'positioned' (absolutely positioned or centered)
	 * 
	 */
	maxWidth?: number | string

	/**
	 * The minimum height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	minHeight?: number | string

	/**
	 * The minimum width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	minWidth?: number | string

	/**
	 * `true` to make this Component modal. This will create a mask underneath the Component
	 * that covers its parent and does not allow the user to interact with any other Components until this
	 * Component is dismissed.
	 * 
	 */
	modal?: boolean

	/**
	 * Name for the widget to be used with Ext.Container#lookupName et al.
	 * 
	 */
	name?: string

	/**
	 * [Children](https://github.com/d3/d3-hierarchy/#hierarchy) accessor function.
	 * Defaults to returning node's nodes,
	 * if the node is expanded or null otherwise
	 * (meaning children of collapsed nodes are not rendered).
	 * 
	 */
	nodeChildren?: Function

	/**
	 * A function that updates class attributes of a given selection.
	 * By default adds the following classes to node elements:
	 * - `x-d3-parent` - if a node is a parent node;
	 * - `x-d3-leaf` - if a node is a leaf node;
	 * - `x-d3-expanded` - if a node is expanded;
	 * - `x-d3-root` - if a node is the root node (represents the root of the store);
	 * - `x-d3-layout-root` - if a node is the root node of the current layout.
	 * 
	 */
	nodeClass?: Function

	/**
	 * The [key](https://github.com/d3/d3-selection/#selection_data) function for nodes.
	 * Returns the 'id' of the node's Ext.data.TreeModel by default.
	 * 
	 */
	nodeKey?: Function

	/**
	 * A function that returns a text string, given a component and  node (d3.hierarchy) instance.
	 * Alternatively, can be a field name or an array of field names used to fetch the text.
	 * If array of field names is given, the first non-empty string will be used.
	 * A node holds a reference to the Ext.data.TreeModel instance
	 * in its `data` field.
	 * For example, to return the value of the record's field `name` as node's text
	 * the following function can be used:
	 * 
	 *     nodeText: function (component, node) {
	 *         var record = node.data,
	 *             text = record.get('name');
	 * 
	 *         return text;
	 *     }
	 * 
	 * Or simply:
	 * 
	 *     nodeText: 'name'
	 * 
	 * To return the value of the `title` field, if the `name` field is empty:
	 * 
	 *     nodeText: ['name', 'title']
	 * 
	 */
	nodeText?: Function | string | string[]

	/**
	 * By default, the area occupied by the node depends on the number
	 * of children the node has, but cannot be zero, so that leaf
	 * nodes are still visible.
	 * 
	 */
	nodeValue?: any

	/**
	 * If `true` the nodeValue function will not be called for parent nodes,
	 * instead they'll get a value of zero.
	 * The nodeChildren function is used to determine if a node is a parent.
	 * 
	 */
	noParentValue?: boolean

	/**
	 * The padding of the scene.
	 * See Ext.util.Format#parseBox for syntax details,
	 * if using a string for this config.
	 * 
	 */
	padding?: any | string | number

	/**
	 * An object or array of objects that will provide custom functionality for this
	 * component. If a string is provided or a string is one of the elements of the
	 * array, that string is treated as the `type` alias. For example, "listpaging"
	 * is the type alias for `Ext.plugin.ListPaging`. The full alias includes the
	 * "plugin." prefix (i.e., 'plugin.listpaging').
	 * 
	 * Plugins should derive from `Ext.plugin.Abstract` but this is not required. The
	 * only requirement for a valid plugin is that it contain an `init()` method that
	 * accepts a reference to the owning component.
	 * 
	 * When a component is created, if any plugins are available, the component will
	 * call the `init` method on each plugin,
	 * passing a reference to itself. Each plugin can then call methods or respond to
	 * events on the component as needed to provide its functionality.
	 * 
	 * ## Example code
	 * 
	 * A plugin by alias:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: 'listpaging'
	 *      });
	 * 
	 * Multiple plugins by alias:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: ['listpaging', 'pullrefresh']
	 *      });
	 * 
	 * Single plugin by class name with config options:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: {
	 *              type: 'listpaging',
	 *              autoPaging: true
	 *          }
	 *      });
	 * 
	 * Multiple plugins by type and class name with config options:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: [{
	 *              xclass: 'Ext.plugin.PullRefresh',
	 *              pullRefreshText: 'Pull to refresh...'
	 *          }, {
	 *              type: 'listpaging',
	 *              autoPaging: true
	 *          }]
	 *      });
	 * 
	 */
	plugins?: any | string | any[] | string[]

	/**
	 * A model instance which updates the Component's html based on it's tpl. Similar to the data
	 * configuration, but tied to to a record to make allow dynamic updates.  This must be a model
	 * instance and not a configuration of one.
	 * 
	 */
	record?: any

	/**
	 * Optional element to render this Component to.
	 * Not required if this component is an item of a Container of a Container.
	 * 
	 */
	renderTo?: any

	/**
	 * The absolute right position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	right?: number | string

	/**
	 * False to hide the root node.
	 * 
	 */
	rootVisible?: boolean

	/**
	 * Configuration options to make this Component scrollable. Acceptable values are:
	 * 
	 * - `true` to enable auto scrolling.
	 * - `false` (or `null`) to disable scrolling - this is the default.
	 * - `x` or `horizontal` to enable horizontal scrolling only
	 * - `y` or `vertical` to enable vertical scrolling only
	 * 
	 * Also accepts a configuration object for a `Ext.scroll.Scroller` if
	 * if advanced configuration is needed.
	 * 
	 * The getter for this config returns the Ext.scroll.Scroller
	 * instance.  You can use the Scroller API to read or manipulate the scroll position:
	 * 
	 *     // scrolls the component to 5 on the x axis and 10 on the y axis
	 *     component.getScrollable().scrollTo(5, 10);
	 * 
	 */
	scrollable?: boolean | string | any

	/**
	 * The select event(s) to listen for on each node.
	 * The node in question will be selected,
	 * selection will be removed from the previously selected node.
	 * The select event won't be handled when Ctrl/Cmd is pressed.
	 * For example, this allows to expand a node by double-clicking
	 * without selecting it.
	 * `false` can be used to prevent listening for the default event.
	 * 
	 */
	selectEventName?: string | string[] | any

	/**
	 * The selected record. Typically used with binding.
	 * 
	 */
	selection?: any

	/**
	 * Animation effect to apply when the Component is being shown.  Typically you want to use an
	 * inbound animation type such as 'fadeIn' or 'slideIn'. For more animations, check the Ext.fx.Animation#type config.
	 * 
	 */
	showAnimation?: string | any

	/**
	 * Whether or not the component got its first size.
	 * Can be used in the `sceneresize` event handler to do user-defined setup on first
	 * resize, for example:
	 * 
	 *     listeners: {
	 *         sceneresize: function (component, scene, rect) {
	 *             if (!component.size) {
	 *                 // set things up
	 *             } else {
	 *                 // handle resize
	 *             }
	 *         }
	 *     }
	 * 
	 */
	size?: any

	/**
	 * The store with data to render.
	 * 
	 */
	store?: any

	/**
	 * Additional CSS styles that will be rendered into an inline style attribute when
	 * the widget is rendered.
	 * 
	 * You can pass either a string syntax:
	 * 
	 *     style: 'background:red'
	 * 
	 * Or by using an object:
	 * 
	 *     style: {
	 *         background: 'red'
	 *     }
	 * 
	 * When using the object syntax, you can define CSS Properties by using a string:
	 * 
	 *     style: {
	 *         'border-left': '1px solid red'
	 *     }
	 * 
	 * Although the object syntax is much easier to read, we suggest you to use the
	 * string syntax for better performance.
	 * 
	 */
	style?: string | any

	/**
	 * DOM tabIndex attribute for this component's focusEl.
	 * 
	 */
	tabIndex?: number

	/**
	 * The padding of a node's text inside its container.
	 * If the length of the text is such that it can't have the specified padding
	 * and still fit into a container, the text will hidden, unless the
	 * clipText config is set to `false`.
	 * It's possible to use negative values for the padding to allow the text to
	 * go outside its container by the specified amount.
	 * Array of two values: horizontal and vertical padding.
	 * 
	 */
	textPadding?: any[]

	/**
	 * The Ext.tip.ToolTip for this component.
	 * 
	 *     <Button text="Basic Tip">
	 *         <ToolTip>A simple tooltip</ToolTip>
	 *     </Button>
	 * 
	 */
	tooltip?: any

	/**
	 * The absolute top position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	top?: number | string

	/**
	 * 
	 * Emulates the behavior of the CSS [touch-action](https://www.w3.org/TR/pointerevents/#the-touch-action-css-property)
	 * property in a cross-browser compatible manner.
	 * 
	 * Keys in this object are touch action names, and values are `false` to disable
	 * a touch action or `true` to enable it.  Accepted keys are:
	 * 
	 * - `panX`
	 * - `panY`
	 * - `pinchZoom`
	 * - `doubleTapZoom`
	 * 
	 * All touch actions are enabled (`true`) by default, so it is usually only necessary
	 * to specify which touch actions to disable.  For example, the following disables
	 * only horizontal scrolling and pinch-to-zoom on the component's main element:
	 * 
	 *     touchAction: {
	 *         panX: false,
	 *         pinchZoom: false
	 *     }
	 * 
	 * Touch actions can be specified on reference elements using the reference element
	 * name, for example:
	 * 
	 *     // disables horizontal scrolling on the main element, and double-tap-zoom
	 *     // on the child element named "body"
	 *     touchAction: {
	 *         panY: false
	 *         body: {
	 *             doubleTapZoom: false
	 *         }
	 *     }
	 * 
	 * The primary motivation for setting the touch-action of an element is to prevent
	 * the browser's default handling of a gesture such as pinch-to-zoom, or
	 * drag-to-scroll, so that the application can implement its own handling of that
	 * gesture on the element.  Suppose, for example, a component has a custom drag
	 * handler on its element and wishes to prevent horizontal scrolling of its container
	 * while it is being dragged:
	 * 
	 *     Ext.create('Ext.Widget', {
	 *         touchAction: {
	 *             panX: false
	 *         },
	 *         listeners: {
	 *             drag: function(e) {
	 *                 // implement drag logic
	 *             }
	 *         }
	 *     });
	 * 
	 */
	touchAction?: any

	/**
	 * 
	 * A string, array of strings, or a function that returns JSX.
	 * 
	 *    tpl = data => <div>{data.first_name} {data.last_name}</div>
	 * 
	 * __Note__
	 * The data configuration _must_ be set for any content to be shown in the component when using this configuration.
	 * 
	 */
	tpl?: Function | string | string[]

	/**
	 * The Ext.(X)Template method to use when updating the content area of the Component.
	 * 
	 * Valid modes are:
	 * 
	 * - append
	 * - insertAfter
	 * - insertBefore
	 * - insertFirst
	 * - overwrite
	 * 
	 */
	tplWriteMode?: string

	/**
	 * A map of transition configs. For example:
	 * 
	 *     transitions: {
	 *         select: {
	 *             duration: 500,
	 *             ease: 'cubicInOut'
	 *         },
	 *         zoom: {
	 *             name: 'zoom',
	 *             duration: 1000
	 *         },
	 *         ...
	 *     }
	 * 
	 * A class would define the defaults for its transitions, and a user only needs
	 * to set the `transitions` config of an instance to disable a transition, e.g.:
	 * 
	 *     transitions: {
	 *         // transitions are enabled by default, `true` should never be used here
	 *         select: false
	 *     }
	 * 
	 * or alter its config:
	 * 
	 *     transitions: {
	 *         select: {
	 *             // the `duration` stays the same,
	 *             // only the easing function is altered
	 *             ease: 'bounceOut'
	 *         }
	 *     }
	 * 
	 * The transitions defined this way are merely configs. To create an actual transition
	 * from one of these configs, use the createTransition method. For example:
	 * 
	 *     this.createTransition('select')
	 * 
	 * A transition object can optionally specify a name, if it's different from
	 * the key in the `transitions` config. For example:
	 * 
	 *     transitions: {
	 *         layout: {
	 *             name: 'foo',
	 *             duration: 500
	 *         }
	 *     }
	 * 
	 * Otherwise the name will be set automatically, for example:
	 * 
	 *     transition.name = this.getId() + '-' + key
	 * 
	 * Transition names (whether explicitly given or not) are prefixed by component ID
	 * to prevent transitions with the same name but on a different component from
	 * cancelling each other out.
	 * 
	 * However, transitions with the same name on the same component will still cancel
	 * each other out, if created via createTransition on the same selection
	 * or with no selection provided.
	 * 
	 * `duration`, `ease` and `name` properties of transition objects in this config
	 * are reserved, and will be used to configure a `d3.transition` instance.
	 * However, transition objects may also have other properties that are related to
	 * this transition. For example:
	 * 
	 *     transitions: {
	 *         select: {
	 *             duration: 500,
	 *             ease: 'cubicInOut',
	 *             targetScale: 1.1
	 *         }
	 *     }
	 * 
	 * The `targetScale` property here won't be consumed by a `d3.transition` instance;
	 * instead a component can make use of it in whichever way it sees fit to animate
	 * the selected element.
	 * 
	 */
	transitions?: any

	/**
	 * The ui or uis to be used on this Component
	 * 
	 * When a ui is configured, CSS class names are added to the element, created
	 * by appending the ui name(s) to each classCls and/or baseCls.
	 * 
	 */
	ui?: string | string[]

	/**
	 * One or more CSS classes to add to the component's primary element. This config
	 * is intended solely for use by the component instantiator (the "user"), not by
	 * derived classes.
	 * 
	 * For example:
	 * 
	 *      items: [{
	 *          xtype: 'button',
	 *          userCls: 'my-button'
	 *      ...
	 *      }]
	 * 
	 */
	userCls?: string | string[]

	/**
	 * This value controls this item's order in a Ext.Container#cfg!weighted
	 * Ext.Container (see cfg!parent).
	 * 
	 * Lower values gravitate towards the start of the container - the top in vertical layouts, the
	 * locale start side in horizontal layouts.
	 * 
	 */
	weight?: number

	/**
	 * The width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	width?: number | string

	/**
	 * The z-index to give this Component when it is rendered.
	 * 
	 * Not valid for cfg-floated Components. The Z ordering of cfg-floated
	 * Components is managed by ordering of the DOM elements.
	 * 
	 */
	zIndex?: number

	/**
	 * Fires after a Component had been added to a Container.
	 * 
	 */
	onAdded?: (me: any, container: any, index: number) => void

	/**
	 * This event fires when `cfg!bottom` changes.
	 */
	onBeforeBottomChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!centered` changes.
	 */
	onBeforeCenteredChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!disabled` changes.
	 */
	onBeforeDisabledChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!docked` changes.
	 */
	onBeforeDockedChange?: (sender: any, value: string, oldValue: string) => void

	/**
	 * This event fires when `cfg!height` changes.
	 */
	onBeforeHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!hidden` changes.
	 */
	onBeforeHiddenChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires before the Component is hidden. Hide may be vetoed by returning `false` from a handler.
	 * 
	 */
	onBeforeHide?: (me: any) => void

	/**
	 * This event fires when `cfg!left` changes.
	 */
	onBeforeLeftChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxHeight` changes.
	 */
	onBeforeMaxHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxWidth` changes.
	 */
	onBeforeMaxWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minHeight` changes.
	 */
	onBeforeMinHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minWidth` changes.
	 */
	onBeforeMinWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!right` changes.
	 */
	onBeforeRightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!scrollable` changes.
	 */
	onBeforeScrollableChange?: (sender: any, value: boolean | string | any, oldValue: boolean | string | any) => void

	/**
	 * Fires before the Component is shown. Show may be vetoed by returning `false` from a handler.
	 * 
	 */
	onBeforeShow?: (me: any) => void

	/**
	 * This event fires when `cfg!top` changes.
	 */
	onBeforeTopChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!width` changes.
	 */
	onBeforeWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires when this Component's focusEl loses focus.
	 * 
	 */
	onBlur?: (me: any, event: any) => void

	/**
	 * This event fires when `cfg!bottom` changes.
	 */
	onBottomChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!centered` changes.
	 */
	onCenteredChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires when the component is destroyed
	 * 
	 */
	onDestroy?: () => void

	/**
	 * This event fires when `cfg!disabled` changes.
	 */
	onDisabledChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!docked` changes.
	 */
	onDockedChange?: (sender: any, value: string, oldValue: string) => void

	/**
	 * Fires when the component is no longer displayed in the DOM.  Listening to this event will
	 * degrade performance not recommend for general use.
	 * 
	 */
	onErased?: (me: any) => void

	/**
	 * Fires when this Component's focusEl receives focus.
	 * 
	 */
	onFocus?: (me: any, event: any) => void

	/**
	 * Fires when focus enters this Component's hierarchy.
	 * 
	 */
	onFocusEnter?: (me: any, event: any) => void

	/**
	 * Fires when focus leaves this Component's hierarchy.
	 * 
	 */
	onFocusLeave?: (me: any, event: any) => void

	/**
	 * Fires whenever a Component with the fullscreen config is instantiated
	 * 
	 */
	onFullscreen?: (me: any) => void

	/**
	 * This event fires when `cfg!height` changes.
	 */
	onHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!hidden` changes.
	 */
	onHiddenChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires whenever the Component is hidden
	 * 
	 */
	onHide?: (me: any) => void

	/**
	 * Fires when the component has been initialized
	 * 
	 */
	onInitialize?: (me: any) => void

	/**
	 * This event fires when `cfg!left` changes.
	 */
	onLeftChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxHeight` changes.
	 */
	onMaxHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxWidth` changes.
	 */
	onMaxWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minHeight` changes.
	 */
	onMinHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minWidth` changes.
	 */
	onMinWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires when a component si moved within its Container.
	 * 
	 */
	onMoved?: (me: any, container: any, toIndex: number, fromIndex: number) => void

	/**
	 * Fires whenever this Element actually becomes visible (painted) on the screen. This is useful when you need to
	 * perform 'read' operations on the DOM element, i.e: calculating natural sizes and positioning.
	 * 
	 * __Note:__ This event is not available to be used with event delegation. Instead `painted` only fires if you explicitly
	 * add at least one listener to it, for performance reasons.
	 * 
	 */
	onPainted?: (element: any) => void

	/**
	 * Fires whenever there is a change in the positioned status of a component
	 * 
	 */
	onPositionedChange?: (me: any, positioned: boolean) => void

	/**
	 * Fires when a component is removed from a Container
	 * 
	 */
	onRemoved?: (me: any, container: any, index: number) => void

	/**
	 * Fires *asynchronously* after a browser layout caused by a component resize. This may be triggered for any or
	 * several of the following reasons:
	 *    - Programmatic changes to cfg-width or cfg-height configs.
	 *    - Setting the cfg-flex config when the owning layout is Ext.layout.Box.
	 *    - Setting cfg-minHeight, cfg-maxHeight, cfg-minWidth or cfg-maxWidth.
	 *    - Changing device orientation.
	 *    - Changing the browser viewport size.
	 *    - Any resize caused by browser layout recalculation which may be caused by content size changes
	 *      or application of default browser layout rules.
	 * 
	 */
	onResize?: (component: any, width: string | number, height: string | number, oldWidth: string | number, oldHeight: string | number) => void

	/**
	 * This event fires when `cfg!right` changes.
	 */
	onRightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires after scene size has changed.
	 * Notes: the scene is a 'g' element, so it cannot actually have a size.
	 * The size reported is the size the drawing is supposed to fit in.
	 * 
	 */
	onSceneResize?: (component: any, scene: any, size: any) => void

	/**
	 * Fires once after the scene has been created.
	 * Note that at this time the component doesn't have a size yet.
	 * 
	 */
	onSceneSetup?: (component: any, scene: any) => void

	/**
	 * This event fires when `cfg!scrollable` changes.
	 */
	onScrollableChange?: (sender: any, value: boolean | string | any, oldValue: boolean | string | any) => void

	/**
	 * Fires whenever the Component is shown
	 * 
	 */
	onShow?: (me: any) => void

	/**
	 * This event fires when `cfg!top` changes.
	 */
	onTopChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!width` changes.
	 */
	onWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void
}

/**
 * Abstract class for D3 components
 * with the [Partition layout](https://github.com/mbostock/d3/wiki/Partition-Layout).
 * 
 */
declare class D3_Partition extends React.Component<D3_PartitionProps, any> { }
export interface D3_PartitionProps extends FlexibleProps {

	/**
	 * An object containing ARIA attributes to be set
	 * on this Component's ARIA element. Use this to set the attributes that cannot be
	 * determined by the Component's state, such as `aria-live`, `aria-flowto`, etc.
	 * 
	 * **Note** that this config is only meaningful at the Component rendering time,
	 * and setting it after that will do nothing.
	 * 
	 */
	ariaAttributes?: any

	/**
	 * DOM selector for a child element that is to be used
	 * as description for this Component, set in `aria-describedby` attribute.
	 * The selector works the same way as ariaLabelledBy.
	 * 
	 */
	ariaDescribedBy?: string

	/**
	 * ARIA label for this Component. It is best to use
	 * ariaLabelledBy option instead, because screen readers prefer
	 * `aria-labelledby` attribute to `aria-label`. ariaLabel and
	 * ariaLabelledBy config options are mutually exclusive.
	 * 
	 */
	ariaLabel?: string

	/**
	 * DOM selector for a child element that is to be used
	 * as label for this Component, set in `aria-labelledby` attribute.
	 * If the selector is by `#id`, the label element can be any existing element,
	 * not necessarily a child of the main Component element.
	 * 
	 * ariaLabelledBy and ariaLabel config options are
	 * mutually exclusive, and `ariaLabelledBy` has the higher precedence.
	 * 
	 */
	ariaLabelledBy?: string

	/**
	 * If `true`, then, when showBy or alignTo fallback on
	 * constraint violation only takes place along the major align axis.
	 * 
	 * That is, if alignment `"l-r"` is being used, and `axisLock: true` is used, then if constraints
	 * fail, only fallback to `"r-l"` is considered.
	 * 
	 */
	axisLock?: boolean

	/**
	 * 
	 * Enables or disables bordering on this component.
	 * The following values are accepted:
	 * 
	 * - `null` or `true (default): Do nothing and allow the border to be specified by the theme.
	 * - `false`: suppress the default border provided by the theme.
	 * 
	 * Please note that enabling bordering via this config will not add a `border-color`
	 * or `border-style` CSS property to the component; you provide the `border-color`
	 * and `border-style` via CSS rule or style configuration
	 * (if not already provide by the theme).
	 * 
	 */
	border?: boolean

	/**
	 * The absolute bottom position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	bottom?: number | string

	/**
	 * Configure this as `true` to have this Component centered within its Container.
	 * Setting this value to `true` will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	centered?: boolean

	/**
	 * If the scene elements that go outside the scene and into the padding area
	 * should be clipped.
	 * Note: stock D3 components are not designed to work with this config set to `true`.
	 * 
	 */
	clipScene?: boolean

	/**
	 * The CSS class to add to this widget's element, in
	 * addition to the baseCls. In many cases, this property will be specified
	 * by the derived widget class. See userCls for adding additional CSS
	 * classes to widget instances (such as items in a Ext.Container).
	 * 
	 */
	cls?: string | string[]

	/**
	 * A Ext.d3.axis.Color config or an instance.
	 * By default (if no 'colorAxis' config is given) all nodes
	 * are assigned a unique color from the `d3.scale.category20c`
	 * scale (until the colors run out, then we start to reuse them)
	 * based on the value of the `name` field.
	 * 
	 */
	colorAxis?: any

	/**
	 * The CSS class used by a subclass of the D3 Component.
	 * Normally, the lower-cased name of a subclass.
	 * 
	 */
	componentCls?: string

	/**
	 * The configured element will automatically be
	 * added as the content of this component. When you pass a string, we expect it to be an element id.
	 * If the content element is hidden, we will automatically show it.
	 * 
	 */
	contentEl?: any | HTMLElement | string

	/**
	 * The initial set of data to apply to the `tpl` to
	 * update the content area of the Component.
	 * 
	 */
	data?: any

	/**
	 * Whether or not this component is disabled
	 * 
	 */
	disabled?: boolean

	/**
	 * The dock position of this component in its container. Can be `left`, `top`, `right` or `bottom`.
	 * 
	 * __Notes__
	 * 
	 * You must use a HTML5 doctype for docked `bottom` to work. To do this, simply add the following code to the HTML file:
	 * 
	 *     <!doctype html>
	 * 
	 * So your index.html file should look a little like this:
	 * 
	 *     <!doctype html>
	 *     <html>
	 *         <head>
	 *             <title>MY application title</title>
	 *             ...
	 * 
	 */
	docked?: string

	/**
	 * Configuration options to make this Component draggable
	 * 
	 */
	draggable?: any

	/**
	 * The expand event(s) to listen for on each node.
	 * The node in question will be expanded, if collapsed,
	 * or collapsed, if expanded.
	 * `false` can be used to prevent listening for the default event.
	 * 
	 */
	expandEventName?: string | string[] | any

	/**
	 * CSS class that will be added to focused
	 * component's focusClsEl, and removed when component blurs.
	 * 
	 */
	focusCls?: string

	/**
	 * Force the component to take up 100% width and height available, by adding it
	 * to Ext.Viewport.
	 * 
	 */
	fullscreen?: boolean

	/**
	 * The height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	height?: number | string

	/**
	 * Whether or not this Component is hidden (its CSS `display` property is set to `none`).
	 * 
	 * Defaults to `true` for floated Components.
	 * 
	 */
	hidden?: boolean

	/**
	 * Animation effect to apply when the Component is being hidden.  Typically you want to use an
	 * outbound animation type such as 'fadeOut' or 'slideOut'. For more animations, check the Ext.fx.Animation#type config.
	 * 
	 */
	hideAnimation?: string | any

	/**
	 * When using a cfg!modal Component, setting this to `true`
	 * will hide the modal mask and the Container when the mask is tapped on.
	 * 
	 */
	hideOnMaskTap?: boolean

	/**
	 * The class name added to all hierarchy components (subclasses).
	 * See also componentCls.
	 * 
	 */
	hierarchyCls?: string

	/**
	 * Optional HTML content to render inside this Component, or a reference
	 * to an existing element on the page.
	 * 
	 */
	html?: string | any | HTMLElement

	/**
	 * The list of interaction configs for this D3 component.
	 * D3 package interactions are very similar to native D3 behaviors.
	 * However, D3 behaviors, as well as event system, is incompatible
	 * with ExtJS event system. D3 package interactions may also support
	 * certain features that D3 behaviors lack, like like kinetic scrolling,
	 * elastic borders and scroll indicators (see the Ext.d3.interaction.PanZoom
	 * interaction for more information).
	 * 
	 */
	interactions?: any[]

	/**
	 * An object containing handlers for keyboard events. The property names of this
	 * object are the key name and any modifiers. The values of the properties are the
	 * descriptors of how to handle each event.
	 * 
	 * The handler descriptor can be simply the handler function (either the
	 * literal function or the method name), or it can be an object with these
	 * properties:
	 * 
	 *  - `handler`: The function or its name to call to handle the event.
	 *  - `scope`: The this pointer context (can be "this" or "controller").
	 *  - `event`: An optional override of the key event to which to listen.
	 * 
	 * **Important:** Calls to `setKeyMap` do not replace the entire `keyMap` but
	 * instead update the provided mappings. That is, unless `null` is passed as the
	 * value of the `keyMap` which will clear the `keyMap` of all entries.
	 * 
	 */
	keyMap?: any

	/**
	 * Enables or disables processing keys in the `keyMap`. This value starts as
	 * `null` and if it is `null` when `initKeyMap` is called, it will automatically
	 * be set to `true`. Since `initKeyMap` is called by `Ext.Component` at the
	 * proper time, this is not something application code normally handles.
	 * 
	 */
	keyMapEnabled?: boolean

	/**
	 * The absolute left position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	left?: number | string

	/**
	 * The [key](https://github.com/d3/d3-selection/#selection_data) function for links.
	 * Returns the 'id' of the link's target Ext.data.TreeModel by default.
	 * 
	 */
	linkKey?: Function

	/**
	 * 
	 * A config object containing one or more event handlers to be added to this object during initialization. This
	 * should be a valid listeners config object as specified in the
	 * addListener example for attaching
	 * multiple handlers at once.
	 * 
	 * **DOM events from Ext JS Ext.Component**
	 * 
	 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
	 * only done when extra value can be added. For example the DataView's **`itemclick`** event passing the node clicked on. To access DOM events directly from a
	 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
	 * DOM listener to:
	 * 
	 *     new Ext.panel.Panel({
	 *         width: 400,
	 *         height: 200,
	 *         dockedItems: [{
	 *             xtype: 'toolbar'
	 *         }],
	 *         listeners: {
	 *             click: {
	 *                 element: 'el', //bind to the underlying el property on the panel
	 *                 fn: function(){ console.log('click el'); }
	 *             },
	 *             dblclick: {
	 *                 element: 'body', //bind to the underlying body property on the panel
	 *                 fn: function(){ console.log('dblclick body'); }
	 *             }
	 *         }
	 *     });
	 * 
	 */
	listeners?: any

	/**
	 * The margin to use on this Component. Can be specified as a number (in which case
	 * all edges get the same margin) or a CSS string like '5 10 10 10'
	 * 
	 */
	margin?: number | string

	/**
	 * The maximum height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * Note that this config will not apply if the Component is 'positioned' (absolutely positioned or centered)
	 * 
	 */
	maxHeight?: number | string

	/**
	 * The maximum width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * Note that this config will not apply if the Component is 'positioned' (absolutely positioned or centered)
	 * 
	 */
	maxWidth?: number | string

	/**
	 * The minimum height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	minHeight?: number | string

	/**
	 * The minimum width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	minWidth?: number | string

	/**
	 * `true` to make this Component modal. This will create a mask underneath the Component
	 * that covers its parent and does not allow the user to interact with any other Components until this
	 * Component is dismissed.
	 * 
	 */
	modal?: boolean

	/**
	 * Name for the widget to be used with Ext.Container#lookupName et al.
	 * 
	 */
	name?: string

	/**
	 * [Children](https://github.com/d3/d3-hierarchy/#hierarchy) accessor function.
	 * Defaults to returning node's nodes,
	 * if the node is expanded or null otherwise
	 * (meaning children of collapsed nodes are not rendered).
	 * 
	 */
	nodeChildren?: Function

	/**
	 * A function that updates class attributes of a given selection.
	 * By default adds the following classes to node elements:
	 * - `x-d3-parent` - if a node is a parent node;
	 * - `x-d3-leaf` - if a node is a leaf node;
	 * - `x-d3-expanded` - if a node is expanded;
	 * - `x-d3-root` - if a node is the root node (represents the root of the store);
	 * - `x-d3-layout-root` - if a node is the root node of the current layout.
	 * 
	 */
	nodeClass?: Function

	/**
	 * The [key](https://github.com/d3/d3-selection/#selection_data) function for nodes.
	 * Returns the 'id' of the node's Ext.data.TreeModel by default.
	 * 
	 */
	nodeKey?: Function

	/**
	 * A function that returns a text string, given a component and  node (d3.hierarchy) instance.
	 * Alternatively, can be a field name or an array of field names used to fetch the text.
	 * If array of field names is given, the first non-empty string will be used.
	 * A node holds a reference to the Ext.data.TreeModel instance
	 * in its `data` field.
	 * For example, to return the value of the record's field `name` as node's text
	 * the following function can be used:
	 * 
	 *     nodeText: function (component, node) {
	 *         var record = node.data,
	 *             text = record.get('name');
	 * 
	 *         return text;
	 *     }
	 * 
	 * Or simply:
	 * 
	 *     nodeText: 'name'
	 * 
	 * To return the value of the `title` field, if the `name` field is empty:
	 * 
	 *     nodeText: ['name', 'title']
	 * 
	 */
	nodeText?: Function | string | string[]

	/**
	 * [The function](https://github.com/d3/d3-hierarchy#node_sum) that receives
	 * the node's data (tree store record) and returns the numeric value of the node.
	 * This config can also be a field name or a number, in which case it will be
	 * converted to a function that returns the value of the specified field,
	 * or a function that returns the given number for all nodes.
	 * Note: nodeChildren does not have effect on this config, even
	 * though only expanded nodes will render by default, the `nodeValue`
	 * function will be called for all nodes.
	 * 
	 */
	nodeValue?: Function | string | number

	/**
	 * If `true` the nodeValue function will not be called for parent nodes,
	 * instead they'll get a value of zero.
	 * The nodeChildren function is used to determine if a node is a parent.
	 * 
	 */
	noParentValue?: boolean

	/**
	 * The padding of the scene.
	 * See Ext.util.Format#parseBox for syntax details,
	 * if using a string for this config.
	 * 
	 */
	padding?: any | string | number

	/**
	 * An object or array of objects that will provide custom functionality for this
	 * component. If a string is provided or a string is one of the elements of the
	 * array, that string is treated as the `type` alias. For example, "listpaging"
	 * is the type alias for `Ext.plugin.ListPaging`. The full alias includes the
	 * "plugin." prefix (i.e., 'plugin.listpaging').
	 * 
	 * Plugins should derive from `Ext.plugin.Abstract` but this is not required. The
	 * only requirement for a valid plugin is that it contain an `init()` method that
	 * accepts a reference to the owning component.
	 * 
	 * When a component is created, if any plugins are available, the component will
	 * call the `init` method on each plugin,
	 * passing a reference to itself. Each plugin can then call methods or respond to
	 * events on the component as needed to provide its functionality.
	 * 
	 * ## Example code
	 * 
	 * A plugin by alias:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: 'listpaging'
	 *      });
	 * 
	 * Multiple plugins by alias:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: ['listpaging', 'pullrefresh']
	 *      });
	 * 
	 * Single plugin by class name with config options:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: {
	 *              type: 'listpaging',
	 *              autoPaging: true
	 *          }
	 *      });
	 * 
	 * Multiple plugins by type and class name with config options:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: [{
	 *              xclass: 'Ext.plugin.PullRefresh',
	 *              pullRefreshText: 'Pull to refresh...'
	 *          }, {
	 *              type: 'listpaging',
	 *              autoPaging: true
	 *          }]
	 *      });
	 * 
	 */
	plugins?: any | string | any[] | string[]

	/**
	 * A model instance which updates the Component's html based on it's tpl. Similar to the data
	 * configuration, but tied to to a record to make allow dynamic updates.  This must be a model
	 * instance and not a configuration of one.
	 * 
	 */
	record?: any

	/**
	 * Optional element to render this Component to.
	 * Not required if this component is an item of a Container of a Container.
	 * 
	 */
	renderTo?: any

	/**
	 * The absolute right position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	right?: number | string

	/**
	 * False to hide the root node.
	 * 
	 */
	rootVisible?: boolean

	/**
	 * Configuration options to make this Component scrollable. Acceptable values are:
	 * 
	 * - `true` to enable auto scrolling.
	 * - `false` (or `null`) to disable scrolling - this is the default.
	 * - `x` or `horizontal` to enable horizontal scrolling only
	 * - `y` or `vertical` to enable vertical scrolling only
	 * 
	 * Also accepts a configuration object for a `Ext.scroll.Scroller` if
	 * if advanced configuration is needed.
	 * 
	 * The getter for this config returns the Ext.scroll.Scroller
	 * instance.  You can use the Scroller API to read or manipulate the scroll position:
	 * 
	 *     // scrolls the component to 5 on the x axis and 10 on the y axis
	 *     component.getScrollable().scrollTo(5, 10);
	 * 
	 */
	scrollable?: boolean | string | any

	/**
	 * The select event(s) to listen for on each node.
	 * The node in question will be selected,
	 * selection will be removed from the previously selected node.
	 * The select event won't be handled when Ctrl/Cmd is pressed.
	 * For example, this allows to expand a node by double-clicking
	 * without selecting it.
	 * `false` can be used to prevent listening for the default event.
	 * 
	 */
	selectEventName?: string | string[] | any

	/**
	 * The selected record. Typically used with binding.
	 * 
	 */
	selection?: any

	/**
	 * Animation effect to apply when the Component is being shown.  Typically you want to use an
	 * inbound animation type such as 'fadeIn' or 'slideIn'. For more animations, check the Ext.fx.Animation#type config.
	 * 
	 */
	showAnimation?: string | any

	/**
	 * Whether or not the component got its first size.
	 * Can be used in the `sceneresize` event handler to do user-defined setup on first
	 * resize, for example:
	 * 
	 *     listeners: {
	 *         sceneresize: function (component, scene, rect) {
	 *             if (!component.size) {
	 *                 // set things up
	 *             } else {
	 *                 // handle resize
	 *             }
	 *         }
	 *     }
	 * 
	 */
	size?: any

	/**
	 * The store with data to render.
	 * 
	 */
	store?: any

	/**
	 * Additional CSS styles that will be rendered into an inline style attribute when
	 * the widget is rendered.
	 * 
	 * You can pass either a string syntax:
	 * 
	 *     style: 'background:red'
	 * 
	 * Or by using an object:
	 * 
	 *     style: {
	 *         background: 'red'
	 *     }
	 * 
	 * When using the object syntax, you can define CSS Properties by using a string:
	 * 
	 *     style: {
	 *         'border-left': '1px solid red'
	 *     }
	 * 
	 * Although the object syntax is much easier to read, we suggest you to use the
	 * string syntax for better performance.
	 * 
	 */
	style?: string | any

	/**
	 * DOM tabIndex attribute for this component's focusEl.
	 * 
	 */
	tabIndex?: number

	/**
	 * The Ext.tip.ToolTip for this component.
	 * 
	 *     <Button text="Basic Tip">
	 *         <ToolTip>A simple tooltip</ToolTip>
	 *     </Button>
	 * 
	 */
	tooltip?: any

	/**
	 * The absolute top position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	top?: number | string

	/**
	 * 
	 * Emulates the behavior of the CSS [touch-action](https://www.w3.org/TR/pointerevents/#the-touch-action-css-property)
	 * property in a cross-browser compatible manner.
	 * 
	 * Keys in this object are touch action names, and values are `false` to disable
	 * a touch action or `true` to enable it.  Accepted keys are:
	 * 
	 * - `panX`
	 * - `panY`
	 * - `pinchZoom`
	 * - `doubleTapZoom`
	 * 
	 * All touch actions are enabled (`true`) by default, so it is usually only necessary
	 * to specify which touch actions to disable.  For example, the following disables
	 * only horizontal scrolling and pinch-to-zoom on the component's main element:
	 * 
	 *     touchAction: {
	 *         panX: false,
	 *         pinchZoom: false
	 *     }
	 * 
	 * Touch actions can be specified on reference elements using the reference element
	 * name, for example:
	 * 
	 *     // disables horizontal scrolling on the main element, and double-tap-zoom
	 *     // on the child element named "body"
	 *     touchAction: {
	 *         panY: false
	 *         body: {
	 *             doubleTapZoom: false
	 *         }
	 *     }
	 * 
	 * The primary motivation for setting the touch-action of an element is to prevent
	 * the browser's default handling of a gesture such as pinch-to-zoom, or
	 * drag-to-scroll, so that the application can implement its own handling of that
	 * gesture on the element.  Suppose, for example, a component has a custom drag
	 * handler on its element and wishes to prevent horizontal scrolling of its container
	 * while it is being dragged:
	 * 
	 *     Ext.create('Ext.Widget', {
	 *         touchAction: {
	 *             panX: false
	 *         },
	 *         listeners: {
	 *             drag: function(e) {
	 *                 // implement drag logic
	 *             }
	 *         }
	 *     });
	 * 
	 */
	touchAction?: any

	/**
	 * 
	 * A string, array of strings, or a function that returns JSX.
	 * 
	 *    tpl = data => <div>{data.first_name} {data.last_name}</div>
	 * 
	 * __Note__
	 * The data configuration _must_ be set for any content to be shown in the component when using this configuration.
	 * 
	 */
	tpl?: Function | string | string[]

	/**
	 * The Ext.(X)Template method to use when updating the content area of the Component.
	 * 
	 * Valid modes are:
	 * 
	 * - append
	 * - insertAfter
	 * - insertBefore
	 * - insertFirst
	 * - overwrite
	 * 
	 */
	tplWriteMode?: string

	/**
	 * A map of transition configs. For example:
	 * 
	 *     transitions: {
	 *         select: {
	 *             duration: 500,
	 *             ease: 'cubicInOut'
	 *         },
	 *         zoom: {
	 *             name: 'zoom',
	 *             duration: 1000
	 *         },
	 *         ...
	 *     }
	 * 
	 * A class would define the defaults for its transitions, and a user only needs
	 * to set the `transitions` config of an instance to disable a transition, e.g.:
	 * 
	 *     transitions: {
	 *         // transitions are enabled by default, `true` should never be used here
	 *         select: false
	 *     }
	 * 
	 * or alter its config:
	 * 
	 *     transitions: {
	 *         select: {
	 *             // the `duration` stays the same,
	 *             // only the easing function is altered
	 *             ease: 'bounceOut'
	 *         }
	 *     }
	 * 
	 * The transitions defined this way are merely configs. To create an actual transition
	 * from one of these configs, use the createTransition method. For example:
	 * 
	 *     this.createTransition('select')
	 * 
	 * A transition object can optionally specify a name, if it's different from
	 * the key in the `transitions` config. For example:
	 * 
	 *     transitions: {
	 *         layout: {
	 *             name: 'foo',
	 *             duration: 500
	 *         }
	 *     }
	 * 
	 * Otherwise the name will be set automatically, for example:
	 * 
	 *     transition.name = this.getId() + '-' + key
	 * 
	 * Transition names (whether explicitly given or not) are prefixed by component ID
	 * to prevent transitions with the same name but on a different component from
	 * cancelling each other out.
	 * 
	 * However, transitions with the same name on the same component will still cancel
	 * each other out, if created via createTransition on the same selection
	 * or with no selection provided.
	 * 
	 * `duration`, `ease` and `name` properties of transition objects in this config
	 * are reserved, and will be used to configure a `d3.transition` instance.
	 * However, transition objects may also have other properties that are related to
	 * this transition. For example:
	 * 
	 *     transitions: {
	 *         select: {
	 *             duration: 500,
	 *             ease: 'cubicInOut',
	 *             targetScale: 1.1
	 *         }
	 *     }
	 * 
	 * The `targetScale` property here won't be consumed by a `d3.transition` instance;
	 * instead a component can make use of it in whichever way it sees fit to animate
	 * the selected element.
	 * 
	 */
	transitions?: any

	/**
	 * The ui or uis to be used on this Component
	 * 
	 * When a ui is configured, CSS class names are added to the element, created
	 * by appending the ui name(s) to each classCls and/or baseCls.
	 * 
	 */
	ui?: string | string[]

	/**
	 * One or more CSS classes to add to the component's primary element. This config
	 * is intended solely for use by the component instantiator (the "user"), not by
	 * derived classes.
	 * 
	 * For example:
	 * 
	 *      items: [{
	 *          xtype: 'button',
	 *          userCls: 'my-button'
	 *      ...
	 *      }]
	 * 
	 */
	userCls?: string | string[]

	/**
	 * This value controls this item's order in a Ext.Container#cfg!weighted
	 * Ext.Container (see cfg!parent).
	 * 
	 * Lower values gravitate towards the start of the container - the top in vertical layouts, the
	 * locale start side in horizontal layouts.
	 * 
	 */
	weight?: number

	/**
	 * The width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	width?: number | string

	/**
	 * The z-index to give this Component when it is rendered.
	 * 
	 * Not valid for cfg-floated Components. The Z ordering of cfg-floated
	 * Components is managed by ordering of the DOM elements.
	 * 
	 */
	zIndex?: number

	/**
	 * Fires after a Component had been added to a Container.
	 * 
	 */
	onAdded?: (me: any, container: any, index: number) => void

	/**
	 * This event fires when `cfg!bottom` changes.
	 */
	onBeforeBottomChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!centered` changes.
	 */
	onBeforeCenteredChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!disabled` changes.
	 */
	onBeforeDisabledChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!docked` changes.
	 */
	onBeforeDockedChange?: (sender: any, value: string, oldValue: string) => void

	/**
	 * This event fires when `cfg!height` changes.
	 */
	onBeforeHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!hidden` changes.
	 */
	onBeforeHiddenChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires before the Component is hidden. Hide may be vetoed by returning `false` from a handler.
	 * 
	 */
	onBeforeHide?: (me: any) => void

	/**
	 * This event fires when `cfg!left` changes.
	 */
	onBeforeLeftChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxHeight` changes.
	 */
	onBeforeMaxHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxWidth` changes.
	 */
	onBeforeMaxWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minHeight` changes.
	 */
	onBeforeMinHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minWidth` changes.
	 */
	onBeforeMinWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!right` changes.
	 */
	onBeforeRightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!scrollable` changes.
	 */
	onBeforeScrollableChange?: (sender: any, value: boolean | string | any, oldValue: boolean | string | any) => void

	/**
	 * Fires before the Component is shown. Show may be vetoed by returning `false` from a handler.
	 * 
	 */
	onBeforeShow?: (me: any) => void

	/**
	 * This event fires when `cfg!top` changes.
	 */
	onBeforeTopChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!width` changes.
	 */
	onBeforeWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires when this Component's focusEl loses focus.
	 * 
	 */
	onBlur?: (me: any, event: any) => void

	/**
	 * This event fires when `cfg!bottom` changes.
	 */
	onBottomChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!centered` changes.
	 */
	onCenteredChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires when the component is destroyed
	 * 
	 */
	onDestroy?: () => void

	/**
	 * This event fires when `cfg!disabled` changes.
	 */
	onDisabledChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!docked` changes.
	 */
	onDockedChange?: (sender: any, value: string, oldValue: string) => void

	/**
	 * Fires when the component is no longer displayed in the DOM.  Listening to this event will
	 * degrade performance not recommend for general use.
	 * 
	 */
	onErased?: (me: any) => void

	/**
	 * Fires when this Component's focusEl receives focus.
	 * 
	 */
	onFocus?: (me: any, event: any) => void

	/**
	 * Fires when focus enters this Component's hierarchy.
	 * 
	 */
	onFocusEnter?: (me: any, event: any) => void

	/**
	 * Fires when focus leaves this Component's hierarchy.
	 * 
	 */
	onFocusLeave?: (me: any, event: any) => void

	/**
	 * Fires whenever a Component with the fullscreen config is instantiated
	 * 
	 */
	onFullscreen?: (me: any) => void

	/**
	 * This event fires when `cfg!height` changes.
	 */
	onHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!hidden` changes.
	 */
	onHiddenChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires whenever the Component is hidden
	 * 
	 */
	onHide?: (me: any) => void

	/**
	 * Fires when the component has been initialized
	 * 
	 */
	onInitialize?: (me: any) => void

	/**
	 * This event fires when `cfg!left` changes.
	 */
	onLeftChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxHeight` changes.
	 */
	onMaxHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxWidth` changes.
	 */
	onMaxWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minHeight` changes.
	 */
	onMinHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minWidth` changes.
	 */
	onMinWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires when a component si moved within its Container.
	 * 
	 */
	onMoved?: (me: any, container: any, toIndex: number, fromIndex: number) => void

	/**
	 * Fires whenever this Element actually becomes visible (painted) on the screen. This is useful when you need to
	 * perform 'read' operations on the DOM element, i.e: calculating natural sizes and positioning.
	 * 
	 * __Note:__ This event is not available to be used with event delegation. Instead `painted` only fires if you explicitly
	 * add at least one listener to it, for performance reasons.
	 * 
	 */
	onPainted?: (element: any) => void

	/**
	 * Fires whenever there is a change in the positioned status of a component
	 * 
	 */
	onPositionedChange?: (me: any, positioned: boolean) => void

	/**
	 * Fires when a component is removed from a Container
	 * 
	 */
	onRemoved?: (me: any, container: any, index: number) => void

	/**
	 * Fires *asynchronously* after a browser layout caused by a component resize. This may be triggered for any or
	 * several of the following reasons:
	 *    - Programmatic changes to cfg-width or cfg-height configs.
	 *    - Setting the cfg-flex config when the owning layout is Ext.layout.Box.
	 *    - Setting cfg-minHeight, cfg-maxHeight, cfg-minWidth or cfg-maxWidth.
	 *    - Changing device orientation.
	 *    - Changing the browser viewport size.
	 *    - Any resize caused by browser layout recalculation which may be caused by content size changes
	 *      or application of default browser layout rules.
	 * 
	 */
	onResize?: (component: any, width: string | number, height: string | number, oldWidth: string | number, oldHeight: string | number) => void

	/**
	 * This event fires when `cfg!right` changes.
	 */
	onRightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires after scene size has changed.
	 * Notes: the scene is a 'g' element, so it cannot actually have a size.
	 * The size reported is the size the drawing is supposed to fit in.
	 * 
	 */
	onSceneResize?: (component: any, scene: any, size: any) => void

	/**
	 * Fires once after the scene has been created.
	 * Note that at this time the component doesn't have a size yet.
	 * 
	 */
	onSceneSetup?: (component: any, scene: any) => void

	/**
	 * This event fires when `cfg!scrollable` changes.
	 */
	onScrollableChange?: (sender: any, value: boolean | string | any, oldValue: boolean | string | any) => void

	/**
	 * Fires whenever the Component is shown
	 * 
	 */
	onShow?: (me: any) => void

	/**
	 * This event fires when `cfg!top` changes.
	 */
	onTopChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!width` changes.
	 */
	onWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void
}

/**
 * The 'd3-sunburst' component visualizes tree nodes as donut sectors,
 * with the root circle in the center. The angle and area of each sector corresponds
 * to its value. By default
 * the same value is returned for each node, meaning that siblings will span equal
 * angles and occupy equal area.
 * 
 *     @example packages=[d3,reactor]
 *     import React, { Component } from 'react'
 *     import { Container }  from '@extjs/ext-react';
 *     import { D3_Sunburst } from '@extjs/ext-react-d3';
 * 
 *     export default class MyExample extends Component {
 * 
 *         store = Ext.create('Ext.data.TreeStore', {
 *             data: [{
 *                 text: "Oscorp",
 *                 children: [{
 *                     text: 'Norman Osborn'
 *                     },
 *                     {
 *                         text: 'Harry Osborn'
 *                     },
 *                     {
 *                         text: 'Arthur Stacy'
 *                     }
 *                 ]
 *                 },{
 *                 text: "SHIELD",
 *                 children: [{
 *                     text: 'Nick Fury'
 *                     },{
 *                         text: 'Maria Hill'
 *                     },{
 *                         text: 'Tony Stark'
 *                     }
 *                 ]
 *                 },{
 *                 text: "Illuminati",
 *                 children: [{
 *                         text: 'Namor'
 *                     },{
 *                         text: 'Tony Stark'
 *                     },{
 *                         text: 'Reed Richards'
 *                     },{
 *                         text: 'Black Bolt'
 *                     },{
 *                         text: 'Stephen Strange'
 *                     },{
 *                         text: 'Charles Xavier'
 *                     }
 *                 ]
 *             }
 *             ]
 *         });
 * 
 *         render() {
 *             return (
 *                 <Container layout="fit">
 *                     <D3_Sunburst store={this.store} />
 *                 </Container>
 *             )
 *         }
 *     }
 * 
 */
declare class D3_Sunburst extends React.Component<D3_SunburstProps, any> { }
export interface D3_SunburstProps extends FlexibleProps {

	/**
	 * An object containing ARIA attributes to be set
	 * on this Component's ARIA element. Use this to set the attributes that cannot be
	 * determined by the Component's state, such as `aria-live`, `aria-flowto`, etc.
	 * 
	 * **Note** that this config is only meaningful at the Component rendering time,
	 * and setting it after that will do nothing.
	 * 
	 */
	ariaAttributes?: any

	/**
	 * DOM selector for a child element that is to be used
	 * as description for this Component, set in `aria-describedby` attribute.
	 * The selector works the same way as ariaLabelledBy.
	 * 
	 */
	ariaDescribedBy?: string

	/**
	 * ARIA label for this Component. It is best to use
	 * ariaLabelledBy option instead, because screen readers prefer
	 * `aria-labelledby` attribute to `aria-label`. ariaLabel and
	 * ariaLabelledBy config options are mutually exclusive.
	 * 
	 */
	ariaLabel?: string

	/**
	 * DOM selector for a child element that is to be used
	 * as label for this Component, set in `aria-labelledby` attribute.
	 * If the selector is by `#id`, the label element can be any existing element,
	 * not necessarily a child of the main Component element.
	 * 
	 * ariaLabelledBy and ariaLabel config options are
	 * mutually exclusive, and `ariaLabelledBy` has the higher precedence.
	 * 
	 */
	ariaLabelledBy?: string

	/**
	 * If `true`, then, when showBy or alignTo fallback on
	 * constraint violation only takes place along the major align axis.
	 * 
	 * That is, if alignment `"l-r"` is being used, and `axisLock: true` is used, then if constraints
	 * fail, only fallback to `"r-l"` is considered.
	 * 
	 */
	axisLock?: boolean

	/**
	 * 
	 * Enables or disables bordering on this component.
	 * The following values are accepted:
	 * 
	 * - `null` or `true (default): Do nothing and allow the border to be specified by the theme.
	 * - `false`: suppress the default border provided by the theme.
	 * 
	 * Please note that enabling bordering via this config will not add a `border-color`
	 * or `border-style` CSS property to the component; you provide the `border-color`
	 * and `border-style` via CSS rule or style configuration
	 * (if not already provide by the theme).
	 * 
	 */
	border?: boolean

	/**
	 * The absolute bottom position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	bottom?: number | string

	/**
	 * Configure this as `true` to have this Component centered within its Container.
	 * Setting this value to `true` will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	centered?: boolean

	/**
	 * If the scene elements that go outside the scene and into the padding area
	 * should be clipped.
	 * Note: stock D3 components are not designed to work with this config set to `true`.
	 * 
	 */
	clipScene?: boolean

	/**
	 * The CSS class to add to this widget's element, in
	 * addition to the baseCls. In many cases, this property will be specified
	 * by the derived widget class. See userCls for adding additional CSS
	 * classes to widget instances (such as items in a Ext.Container).
	 * 
	 */
	cls?: string | string[]

	/**
	 * A Ext.d3.axis.Color config or an instance.
	 * By default (if no 'colorAxis' config is given) all nodes
	 * are assigned a unique color from the `d3.scale.category20c`
	 * scale (until the colors run out, then we start to reuse them)
	 * based on the value of the `name` field.
	 * 
	 */
	colorAxis?: any

	/**
	 * The CSS class used by a subclass of the D3 Component.
	 * Normally, the lower-cased name of a subclass.
	 * 
	 */
	componentCls?: string

	/**
	 * The configured element will automatically be
	 * added as the content of this component. When you pass a string, we expect it to be an element id.
	 * If the content element is hidden, we will automatically show it.
	 * 
	 */
	contentEl?: any | HTMLElement | string

	/**
	 * The initial set of data to apply to the `tpl` to
	 * update the content area of the Component.
	 * 
	 */
	data?: any

	/**
	 * Whether or not this component is disabled
	 * 
	 */
	disabled?: boolean

	/**
	 * The dock position of this component in its container. Can be `left`, `top`, `right` or `bottom`.
	 * 
	 * __Notes__
	 * 
	 * You must use a HTML5 doctype for docked `bottom` to work. To do this, simply add the following code to the HTML file:
	 * 
	 *     <!doctype html>
	 * 
	 * So your index.html file should look a little like this:
	 * 
	 *     <!doctype html>
	 *     <html>
	 *         <head>
	 *             <title>MY application title</title>
	 *             ...
	 * 
	 */
	docked?: string

	/**
	 * Configuration options to make this Component draggable
	 * 
	 */
	draggable?: any

	/**
	 * The expand event(s) to listen for on each node.
	 * The node in question will be expanded, if collapsed,
	 * or collapsed, if expanded.
	 * `false` can be used to prevent listening for the default event.
	 * 
	 */
	expandEventName?: string | string[] | any

	/**
	 * CSS class that will be added to focused
	 * component's focusClsEl, and removed when component blurs.
	 * 
	 */
	focusCls?: string

	/**
	 * Force the component to take up 100% width and height available, by adding it
	 * to Ext.Viewport.
	 * 
	 */
	fullscreen?: boolean

	/**
	 * The height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	height?: number | string

	/**
	 * Whether or not this Component is hidden (its CSS `display` property is set to `none`).
	 * 
	 * Defaults to `true` for floated Components.
	 * 
	 */
	hidden?: boolean

	/**
	 * Animation effect to apply when the Component is being hidden.  Typically you want to use an
	 * outbound animation type such as 'fadeOut' or 'slideOut'. For more animations, check the Ext.fx.Animation#type config.
	 * 
	 */
	hideAnimation?: string | any

	/**
	 * When using a cfg!modal Component, setting this to `true`
	 * will hide the modal mask and the Container when the mask is tapped on.
	 * 
	 */
	hideOnMaskTap?: boolean

	/**
	 * The class name added to all hierarchy components (subclasses).
	 * See also componentCls.
	 * 
	 */
	hierarchyCls?: string

	/**
	 * Optional HTML content to render inside this Component, or a reference
	 * to an existing element on the page.
	 * 
	 */
	html?: string | any | HTMLElement

	/**
	 * The list of interaction configs for this D3 component.
	 * D3 package interactions are very similar to native D3 behaviors.
	 * However, D3 behaviors, as well as event system, is incompatible
	 * with ExtJS event system. D3 package interactions may also support
	 * certain features that D3 behaviors lack, like like kinetic scrolling,
	 * elastic borders and scroll indicators (see the Ext.d3.interaction.PanZoom
	 * interaction for more information).
	 * 
	 */
	interactions?: any[]

	/**
	 * An object containing handlers for keyboard events. The property names of this
	 * object are the key name and any modifiers. The values of the properties are the
	 * descriptors of how to handle each event.
	 * 
	 * The handler descriptor can be simply the handler function (either the
	 * literal function or the method name), or it can be an object with these
	 * properties:
	 * 
	 *  - `handler`: The function or its name to call to handle the event.
	 *  - `scope`: The this pointer context (can be "this" or "controller").
	 *  - `event`: An optional override of the key event to which to listen.
	 * 
	 * **Important:** Calls to `setKeyMap` do not replace the entire `keyMap` but
	 * instead update the provided mappings. That is, unless `null` is passed as the
	 * value of the `keyMap` which will clear the `keyMap` of all entries.
	 * 
	 */
	keyMap?: any

	/**
	 * Enables or disables processing keys in the `keyMap`. This value starts as
	 * `null` and if it is `null` when `initKeyMap` is called, it will automatically
	 * be set to `true`. Since `initKeyMap` is called by `Ext.Component` at the
	 * proper time, this is not something application code normally handles.
	 * 
	 */
	keyMapEnabled?: boolean

	/**
	 * The absolute left position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	left?: number | string

	/**
	 * The [key](https://github.com/d3/d3-selection/#selection_data) function for links.
	 * Returns the 'id' of the link's target Ext.data.TreeModel by default.
	 * 
	 */
	linkKey?: Function

	/**
	 * 
	 * A config object containing one or more event handlers to be added to this object during initialization. This
	 * should be a valid listeners config object as specified in the
	 * addListener example for attaching
	 * multiple handlers at once.
	 * 
	 * **DOM events from Ext JS Ext.Component**
	 * 
	 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
	 * only done when extra value can be added. For example the DataView's **`itemclick`** event passing the node clicked on. To access DOM events directly from a
	 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
	 * DOM listener to:
	 * 
	 *     new Ext.panel.Panel({
	 *         width: 400,
	 *         height: 200,
	 *         dockedItems: [{
	 *             xtype: 'toolbar'
	 *         }],
	 *         listeners: {
	 *             click: {
	 *                 element: 'el', //bind to the underlying el property on the panel
	 *                 fn: function(){ console.log('click el'); }
	 *             },
	 *             dblclick: {
	 *                 element: 'body', //bind to the underlying body property on the panel
	 *                 fn: function(){ console.log('dblclick body'); }
	 *             }
	 *         }
	 *     });
	 * 
	 */
	listeners?: any

	/**
	 * The margin to use on this Component. Can be specified as a number (in which case
	 * all edges get the same margin) or a CSS string like '5 10 10 10'
	 * 
	 */
	margin?: number | string

	/**
	 * The maximum height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * Note that this config will not apply if the Component is 'positioned' (absolutely positioned or centered)
	 * 
	 */
	maxHeight?: number | string

	/**
	 * The maximum width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * Note that this config will not apply if the Component is 'positioned' (absolutely positioned or centered)
	 * 
	 */
	maxWidth?: number | string

	/**
	 * The minimum height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	minHeight?: number | string

	/**
	 * The minimum width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	minWidth?: number | string

	/**
	 * `true` to make this Component modal. This will create a mask underneath the Component
	 * that covers its parent and does not allow the user to interact with any other Components until this
	 * Component is dismissed.
	 * 
	 */
	modal?: boolean

	/**
	 * Name for the widget to be used with Ext.Container#lookupName et al.
	 * 
	 */
	name?: string

	/**
	 * [Children](https://github.com/d3/d3-hierarchy/#hierarchy) accessor function.
	 * Defaults to returning node's nodes,
	 * if the node is expanded or null otherwise
	 * (meaning children of collapsed nodes are not rendered).
	 * 
	 */
	nodeChildren?: Function

	/**
	 * A function that updates class attributes of a given selection.
	 * By default adds the following classes to node elements:
	 * - `x-d3-parent` - if a node is a parent node;
	 * - `x-d3-leaf` - if a node is a leaf node;
	 * - `x-d3-expanded` - if a node is expanded;
	 * - `x-d3-root` - if a node is the root node (represents the root of the store);
	 * - `x-d3-layout-root` - if a node is the root node of the current layout.
	 * 
	 */
	nodeClass?: Function

	/**
	 * The [key](https://github.com/d3/d3-selection/#selection_data) function for nodes.
	 * Returns the 'id' of the node's Ext.data.TreeModel by default.
	 * 
	 */
	nodeKey?: Function

	/**
	 * A function that returns a text string, given a component and  node (d3.hierarchy) instance.
	 * Alternatively, can be a field name or an array of field names used to fetch the text.
	 * If array of field names is given, the first non-empty string will be used.
	 * A node holds a reference to the Ext.data.TreeModel instance
	 * in its `data` field.
	 * For example, to return the value of the record's field `name` as node's text
	 * the following function can be used:
	 * 
	 *     nodeText: function (component, node) {
	 *         var record = node.data,
	 *             text = record.get('name');
	 * 
	 *         return text;
	 *     }
	 * 
	 * Or simply:
	 * 
	 *     nodeText: 'name'
	 * 
	 * To return the value of the `title` field, if the `name` field is empty:
	 * 
	 *     nodeText: ['name', 'title']
	 * 
	 */
	nodeText?: Function | string | string[]

	/**
	 * [The function](https://github.com/d3/d3-hierarchy#node_sum) that receives
	 * the node's data (tree store record) and returns the numeric value of the node.
	 * This config can also be a field name or a number, in which case it will be
	 * converted to a function that returns the value of the specified field,
	 * or a function that returns the given number for all nodes.
	 * Note: nodeChildren does not have effect on this config, even
	 * though only expanded nodes will render by default, the `nodeValue`
	 * function will be called for all nodes.
	 * 
	 */
	nodeValue?: Function | string | number

	/**
	 * If `true` the nodeValue function will not be called for parent nodes,
	 * instead they'll get a value of zero.
	 * The nodeChildren function is used to determine if a node is a parent.
	 * 
	 */
	noParentValue?: boolean

	/**
	 * The padding of the scene.
	 * See Ext.util.Format#parseBox for syntax details,
	 * if using a string for this config.
	 * 
	 */
	padding?: any | string | number

	/**
	 * An object or array of objects that will provide custom functionality for this
	 * component. If a string is provided or a string is one of the elements of the
	 * array, that string is treated as the `type` alias. For example, "listpaging"
	 * is the type alias for `Ext.plugin.ListPaging`. The full alias includes the
	 * "plugin." prefix (i.e., 'plugin.listpaging').
	 * 
	 * Plugins should derive from `Ext.plugin.Abstract` but this is not required. The
	 * only requirement for a valid plugin is that it contain an `init()` method that
	 * accepts a reference to the owning component.
	 * 
	 * When a component is created, if any plugins are available, the component will
	 * call the `init` method on each plugin,
	 * passing a reference to itself. Each plugin can then call methods or respond to
	 * events on the component as needed to provide its functionality.
	 * 
	 * ## Example code
	 * 
	 * A plugin by alias:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: 'listpaging'
	 *      });
	 * 
	 * Multiple plugins by alias:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: ['listpaging', 'pullrefresh']
	 *      });
	 * 
	 * Single plugin by class name with config options:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: {
	 *              type: 'listpaging',
	 *              autoPaging: true
	 *          }
	 *      });
	 * 
	 * Multiple plugins by type and class name with config options:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: [{
	 *              xclass: 'Ext.plugin.PullRefresh',
	 *              pullRefreshText: 'Pull to refresh...'
	 *          }, {
	 *              type: 'listpaging',
	 *              autoPaging: true
	 *          }]
	 *      });
	 * 
	 */
	plugins?: any | string | any[] | string[]

	/**
	 * A model instance which updates the Component's html based on it's tpl. Similar to the data
	 * configuration, but tied to to a record to make allow dynamic updates.  This must be a model
	 * instance and not a configuration of one.
	 * 
	 */
	record?: any

	/**
	 * Optional element to render this Component to.
	 * Not required if this component is an item of a Container of a Container.
	 * 
	 */
	renderTo?: any

	/**
	 * The absolute right position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	right?: number | string

	/**
	 * False to hide the root node.
	 * 
	 */
	rootVisible?: boolean

	/**
	 * Configuration options to make this Component scrollable. Acceptable values are:
	 * 
	 * - `true` to enable auto scrolling.
	 * - `false` (or `null`) to disable scrolling - this is the default.
	 * - `x` or `horizontal` to enable horizontal scrolling only
	 * - `y` or `vertical` to enable vertical scrolling only
	 * 
	 * Also accepts a configuration object for a `Ext.scroll.Scroller` if
	 * if advanced configuration is needed.
	 * 
	 * The getter for this config returns the Ext.scroll.Scroller
	 * instance.  You can use the Scroller API to read or manipulate the scroll position:
	 * 
	 *     // scrolls the component to 5 on the x axis and 10 on the y axis
	 *     component.getScrollable().scrollTo(5, 10);
	 * 
	 */
	scrollable?: boolean | string | any

	/**
	 * The select event(s) to listen for on each node.
	 * The node in question will be selected,
	 * selection will be removed from the previously selected node.
	 * The select event won't be handled when Ctrl/Cmd is pressed.
	 * For example, this allows to expand a node by double-clicking
	 * without selecting it.
	 * `false` can be used to prevent listening for the default event.
	 * 
	 */
	selectEventName?: string | string[] | any

	/**
	 * The selected record. Typically used with binding.
	 * 
	 */
	selection?: any

	/**
	 * Animation effect to apply when the Component is being shown.  Typically you want to use an
	 * inbound animation type such as 'fadeIn' or 'slideIn'. For more animations, check the Ext.fx.Animation#type config.
	 * 
	 */
	showAnimation?: string | any

	/**
	 * Whether or not the component got its first size.
	 * Can be used in the `sceneresize` event handler to do user-defined setup on first
	 * resize, for example:
	 * 
	 *     listeners: {
	 *         sceneresize: function (component, scene, rect) {
	 *             if (!component.size) {
	 *                 // set things up
	 *             } else {
	 *                 // handle resize
	 *             }
	 *         }
	 *     }
	 * 
	 */
	size?: any

	/**
	 * The store with data to render.
	 * 
	 */
	store?: any

	/**
	 * Additional CSS styles that will be rendered into an inline style attribute when
	 * the widget is rendered.
	 * 
	 * You can pass either a string syntax:
	 * 
	 *     style: 'background:red'
	 * 
	 * Or by using an object:
	 * 
	 *     style: {
	 *         background: 'red'
	 *     }
	 * 
	 * When using the object syntax, you can define CSS Properties by using a string:
	 * 
	 *     style: {
	 *         'border-left': '1px solid red'
	 *     }
	 * 
	 * Although the object syntax is much easier to read, we suggest you to use the
	 * string syntax for better performance.
	 * 
	 */
	style?: string | any

	/**
	 * DOM tabIndex attribute for this component's focusEl.
	 * 
	 */
	tabIndex?: number

	/**
	 * The padding of a node's text inside its container.
	 * 
	 */
	textPadding?: any[]

	/**
	 * The Ext.tip.ToolTip for this component.
	 * 
	 *     <Button text="Basic Tip">
	 *         <ToolTip>A simple tooltip</ToolTip>
	 *     </Button>
	 * 
	 */
	tooltip?: any

	/**
	 * The absolute top position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	top?: number | string

	/**
	 * 
	 * Emulates the behavior of the CSS [touch-action](https://www.w3.org/TR/pointerevents/#the-touch-action-css-property)
	 * property in a cross-browser compatible manner.
	 * 
	 * Keys in this object are touch action names, and values are `false` to disable
	 * a touch action or `true` to enable it.  Accepted keys are:
	 * 
	 * - `panX`
	 * - `panY`
	 * - `pinchZoom`
	 * - `doubleTapZoom`
	 * 
	 * All touch actions are enabled (`true`) by default, so it is usually only necessary
	 * to specify which touch actions to disable.  For example, the following disables
	 * only horizontal scrolling and pinch-to-zoom on the component's main element:
	 * 
	 *     touchAction: {
	 *         panX: false,
	 *         pinchZoom: false
	 *     }
	 * 
	 * Touch actions can be specified on reference elements using the reference element
	 * name, for example:
	 * 
	 *     // disables horizontal scrolling on the main element, and double-tap-zoom
	 *     // on the child element named "body"
	 *     touchAction: {
	 *         panY: false
	 *         body: {
	 *             doubleTapZoom: false
	 *         }
	 *     }
	 * 
	 * The primary motivation for setting the touch-action of an element is to prevent
	 * the browser's default handling of a gesture such as pinch-to-zoom, or
	 * drag-to-scroll, so that the application can implement its own handling of that
	 * gesture on the element.  Suppose, for example, a component has a custom drag
	 * handler on its element and wishes to prevent horizontal scrolling of its container
	 * while it is being dragged:
	 * 
	 *     Ext.create('Ext.Widget', {
	 *         touchAction: {
	 *             panX: false
	 *         },
	 *         listeners: {
	 *             drag: function(e) {
	 *                 // implement drag logic
	 *             }
	 *         }
	 *     });
	 * 
	 */
	touchAction?: any

	/**
	 * 
	 * A string, array of strings, or a function that returns JSX.
	 * 
	 *    tpl = data => <div>{data.first_name} {data.last_name}</div>
	 * 
	 * __Note__
	 * The data configuration _must_ be set for any content to be shown in the component when using this configuration.
	 * 
	 */
	tpl?: Function | string | string[]

	/**
	 * The Ext.(X)Template method to use when updating the content area of the Component.
	 * 
	 * Valid modes are:
	 * 
	 * - append
	 * - insertAfter
	 * - insertBefore
	 * - insertFirst
	 * - overwrite
	 * 
	 */
	tplWriteMode?: string

	/**
	 * A map of transition configs. For example:
	 * 
	 *     transitions: {
	 *         select: {
	 *             duration: 500,
	 *             ease: 'cubicInOut'
	 *         },
	 *         zoom: {
	 *             name: 'zoom',
	 *             duration: 1000
	 *         },
	 *         ...
	 *     }
	 * 
	 * A class would define the defaults for its transitions, and a user only needs
	 * to set the `transitions` config of an instance to disable a transition, e.g.:
	 * 
	 *     transitions: {
	 *         // transitions are enabled by default, `true` should never be used here
	 *         select: false
	 *     }
	 * 
	 * or alter its config:
	 * 
	 *     transitions: {
	 *         select: {
	 *             // the `duration` stays the same,
	 *             // only the easing function is altered
	 *             ease: 'bounceOut'
	 *         }
	 *     }
	 * 
	 * The transitions defined this way are merely configs. To create an actual transition
	 * from one of these configs, use the createTransition method. For example:
	 * 
	 *     this.createTransition('select')
	 * 
	 * A transition object can optionally specify a name, if it's different from
	 * the key in the `transitions` config. For example:
	 * 
	 *     transitions: {
	 *         layout: {
	 *             name: 'foo',
	 *             duration: 500
	 *         }
	 *     }
	 * 
	 * Otherwise the name will be set automatically, for example:
	 * 
	 *     transition.name = this.getId() + '-' + key
	 * 
	 * Transition names (whether explicitly given or not) are prefixed by component ID
	 * to prevent transitions with the same name but on a different component from
	 * cancelling each other out.
	 * 
	 * However, transitions with the same name on the same component will still cancel
	 * each other out, if created via createTransition on the same selection
	 * or with no selection provided.
	 * 
	 * `duration`, `ease` and `name` properties of transition objects in this config
	 * are reserved, and will be used to configure a `d3.transition` instance.
	 * However, transition objects may also have other properties that are related to
	 * this transition. For example:
	 * 
	 *     transitions: {
	 *         select: {
	 *             duration: 500,
	 *             ease: 'cubicInOut',
	 *             targetScale: 1.1
	 *         }
	 *     }
	 * 
	 * The `targetScale` property here won't be consumed by a `d3.transition` instance;
	 * instead a component can make use of it in whichever way it sees fit to animate
	 * the selected element.
	 * 
	 */
	transitions?: any

	/**
	 * The ui or uis to be used on this Component
	 * 
	 * When a ui is configured, CSS class names are added to the element, created
	 * by appending the ui name(s) to each classCls and/or baseCls.
	 * 
	 */
	ui?: string | string[]

	/**
	 * One or more CSS classes to add to the component's primary element. This config
	 * is intended solely for use by the component instantiator (the "user"), not by
	 * derived classes.
	 * 
	 * For example:
	 * 
	 *      items: [{
	 *          xtype: 'button',
	 *          userCls: 'my-button'
	 *      ...
	 *      }]
	 * 
	 */
	userCls?: string | string[]

	/**
	 * This value controls this item's order in a Ext.Container#cfg!weighted
	 * Ext.Container (see cfg!parent).
	 * 
	 * Lower values gravitate towards the start of the container - the top in vertical layouts, the
	 * locale start side in horizontal layouts.
	 * 
	 */
	weight?: number

	/**
	 * The width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	width?: number | string

	/**
	 * The z-index to give this Component when it is rendered.
	 * 
	 * Not valid for cfg-floated Components. The Z ordering of cfg-floated
	 * Components is managed by ordering of the DOM elements.
	 * 
	 */
	zIndex?: number

	/**
	 * The radius of the dot in the center of the sunburst that represents the parent node
	 * of the currently visible node hierarchy and allows to zoom one level up by clicking
	 * or tapping it.
	 * 
	 */
	zoomParentDotRadius?: number

	/**
	 * Fires after a Component had been added to a Container.
	 * 
	 */
	onAdded?: (me: any, container: any, index: number) => void

	/**
	 * This event fires when `cfg!bottom` changes.
	 */
	onBeforeBottomChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!centered` changes.
	 */
	onBeforeCenteredChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!disabled` changes.
	 */
	onBeforeDisabledChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!docked` changes.
	 */
	onBeforeDockedChange?: (sender: any, value: string, oldValue: string) => void

	/**
	 * This event fires when `cfg!height` changes.
	 */
	onBeforeHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!hidden` changes.
	 */
	onBeforeHiddenChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires before the Component is hidden. Hide may be vetoed by returning `false` from a handler.
	 * 
	 */
	onBeforeHide?: (me: any) => void

	/**
	 * This event fires when `cfg!left` changes.
	 */
	onBeforeLeftChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxHeight` changes.
	 */
	onBeforeMaxHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxWidth` changes.
	 */
	onBeforeMaxWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minHeight` changes.
	 */
	onBeforeMinHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minWidth` changes.
	 */
	onBeforeMinWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!right` changes.
	 */
	onBeforeRightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!scrollable` changes.
	 */
	onBeforeScrollableChange?: (sender: any, value: boolean | string | any, oldValue: boolean | string | any) => void

	/**
	 * Fires before the Component is shown. Show may be vetoed by returning `false` from a handler.
	 * 
	 */
	onBeforeShow?: (me: any) => void

	/**
	 * This event fires when `cfg!top` changes.
	 */
	onBeforeTopChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!width` changes.
	 */
	onBeforeWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires when this Component's focusEl loses focus.
	 * 
	 */
	onBlur?: (me: any, event: any) => void

	/**
	 * This event fires when `cfg!bottom` changes.
	 */
	onBottomChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!centered` changes.
	 */
	onCenteredChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires when the component is destroyed
	 * 
	 */
	onDestroy?: () => void

	/**
	 * This event fires when `cfg!disabled` changes.
	 */
	onDisabledChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!docked` changes.
	 */
	onDockedChange?: (sender: any, value: string, oldValue: string) => void

	/**
	 * Fires when the component is no longer displayed in the DOM.  Listening to this event will
	 * degrade performance not recommend for general use.
	 * 
	 */
	onErased?: (me: any) => void

	/**
	 * Fires when this Component's focusEl receives focus.
	 * 
	 */
	onFocus?: (me: any, event: any) => void

	/**
	 * Fires when focus enters this Component's hierarchy.
	 * 
	 */
	onFocusEnter?: (me: any, event: any) => void

	/**
	 * Fires when focus leaves this Component's hierarchy.
	 * 
	 */
	onFocusLeave?: (me: any, event: any) => void

	/**
	 * Fires whenever a Component with the fullscreen config is instantiated
	 * 
	 */
	onFullscreen?: (me: any) => void

	/**
	 * This event fires when `cfg!height` changes.
	 */
	onHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!hidden` changes.
	 */
	onHiddenChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires whenever the Component is hidden
	 * 
	 */
	onHide?: (me: any) => void

	/**
	 * Fires when the component has been initialized
	 * 
	 */
	onInitialize?: (me: any) => void

	/**
	 * This event fires when `cfg!left` changes.
	 */
	onLeftChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxHeight` changes.
	 */
	onMaxHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxWidth` changes.
	 */
	onMaxWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minHeight` changes.
	 */
	onMinHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minWidth` changes.
	 */
	onMinWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires when a component si moved within its Container.
	 * 
	 */
	onMoved?: (me: any, container: any, toIndex: number, fromIndex: number) => void

	/**
	 * Fires whenever this Element actually becomes visible (painted) on the screen. This is useful when you need to
	 * perform 'read' operations on the DOM element, i.e: calculating natural sizes and positioning.
	 * 
	 * __Note:__ This event is not available to be used with event delegation. Instead `painted` only fires if you explicitly
	 * add at least one listener to it, for performance reasons.
	 * 
	 */
	onPainted?: (element: any) => void

	/**
	 * Fires whenever there is a change in the positioned status of a component
	 * 
	 */
	onPositionedChange?: (me: any, positioned: boolean) => void

	/**
	 * Fires when a component is removed from a Container
	 * 
	 */
	onRemoved?: (me: any, container: any, index: number) => void

	/**
	 * Fires *asynchronously* after a browser layout caused by a component resize. This may be triggered for any or
	 * several of the following reasons:
	 *    - Programmatic changes to cfg-width or cfg-height configs.
	 *    - Setting the cfg-flex config when the owning layout is Ext.layout.Box.
	 *    - Setting cfg-minHeight, cfg-maxHeight, cfg-minWidth or cfg-maxWidth.
	 *    - Changing device orientation.
	 *    - Changing the browser viewport size.
	 *    - Any resize caused by browser layout recalculation which may be caused by content size changes
	 *      or application of default browser layout rules.
	 * 
	 */
	onResize?: (component: any, width: string | number, height: string | number, oldWidth: string | number, oldHeight: string | number) => void

	/**
	 * This event fires when `cfg!right` changes.
	 */
	onRightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires after scene size has changed.
	 * Notes: the scene is a 'g' element, so it cannot actually have a size.
	 * The size reported is the size the drawing is supposed to fit in.
	 * 
	 */
	onSceneResize?: (component: any, scene: any, size: any) => void

	/**
	 * Fires once after the scene has been created.
	 * Note that at this time the component doesn't have a size yet.
	 * 
	 */
	onSceneSetup?: (component: any, scene: any) => void

	/**
	 * This event fires when `cfg!scrollable` changes.
	 */
	onScrollableChange?: (sender: any, value: boolean | string | any, oldValue: boolean | string | any) => void

	/**
	 * Fires whenever the Component is shown
	 * 
	 */
	onShow?: (me: any) => void

	/**
	 * This event fires when `cfg!top` changes.
	 */
	onTopChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!width` changes.
	 */
	onWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void
}

/**
 * 
 * The 'd3-horizontal-tree' component is a perfect way to visualize hierarchical
 * data as an actual tree in case where the relative size of nodes is of little
 * interest, and the focus is on the relative position of each node in the hierarchy.
 * A horizontal tree makes for a more consistent look and more efficient use of space
 * when text labels are shown next to each node.
 * 
 */
declare class D3_Tree extends React.Component<D3_TreeProps, any> { }
export interface D3_TreeProps extends FlexibleProps {

	/**
	 * An object containing ARIA attributes to be set
	 * on this Component's ARIA element. Use this to set the attributes that cannot be
	 * determined by the Component's state, such as `aria-live`, `aria-flowto`, etc.
	 * 
	 * **Note** that this config is only meaningful at the Component rendering time,
	 * and setting it after that will do nothing.
	 * 
	 */
	ariaAttributes?: any

	/**
	 * DOM selector for a child element that is to be used
	 * as description for this Component, set in `aria-describedby` attribute.
	 * The selector works the same way as ariaLabelledBy.
	 * 
	 */
	ariaDescribedBy?: string

	/**
	 * ARIA label for this Component. It is best to use
	 * ariaLabelledBy option instead, because screen readers prefer
	 * `aria-labelledby` attribute to `aria-label`. ariaLabel and
	 * ariaLabelledBy config options are mutually exclusive.
	 * 
	 */
	ariaLabel?: string

	/**
	 * DOM selector for a child element that is to be used
	 * as label for this Component, set in `aria-labelledby` attribute.
	 * If the selector is by `#id`, the label element can be any existing element,
	 * not necessarily a child of the main Component element.
	 * 
	 * ariaLabelledBy and ariaLabel config options are
	 * mutually exclusive, and `ariaLabelledBy` has the higher precedence.
	 * 
	 */
	ariaLabelledBy?: string

	/**
	 * If `true`, then, when showBy or alignTo fallback on
	 * constraint violation only takes place along the major align axis.
	 * 
	 * That is, if alignment `"l-r"` is being used, and `axisLock: true` is used, then if constraints
	 * fail, only fallback to `"r-l"` is considered.
	 * 
	 */
	axisLock?: boolean

	/**
	 * 
	 * Enables or disables bordering on this component.
	 * The following values are accepted:
	 * 
	 * - `null` or `true (default): Do nothing and allow the border to be specified by the theme.
	 * - `false`: suppress the default border provided by the theme.
	 * 
	 * Please note that enabling bordering via this config will not add a `border-color`
	 * or `border-style` CSS property to the component; you provide the `border-color`
	 * and `border-style` via CSS rule or style configuration
	 * (if not already provide by the theme).
	 * 
	 */
	border?: boolean

	/**
	 * The absolute bottom position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	bottom?: number | string

	/**
	 * Configure this as `true` to have this Component centered within its Container.
	 * Setting this value to `true` will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	centered?: boolean

	/**
	 * If the scene elements that go outside the scene and into the padding area
	 * should be clipped.
	 * Note: stock D3 components are not designed to work with this config set to `true`.
	 * 
	 */
	clipScene?: boolean

	/**
	 * The CSS class to add to this widget's element, in
	 * addition to the baseCls. In many cases, this property will be specified
	 * by the derived widget class. See userCls for adding additional CSS
	 * classes to widget instances (such as items in a Ext.Container).
	 * 
	 */
	cls?: string | string[]

	/**
	 * A Ext.d3.axis.Color config or an instance.
	 * By default (if no 'colorAxis' config is given) all nodes
	 * are assigned a unique color from the `d3.scale.category20c`
	 * scale (until the colors run out, then we start to reuse them)
	 * based on the value of the `name` field.
	 * 
	 */
	colorAxis?: any

	/**
	 * The CSS class used by a subclass of the D3 Component.
	 * Normally, the lower-cased name of a subclass.
	 * 
	 */
	componentCls?: string

	/**
	 * The configured element will automatically be
	 * added as the content of this component. When you pass a string, we expect it to be an element id.
	 * If the content element is hidden, we will automatically show it.
	 * 
	 */
	contentEl?: any | HTMLElement | string

	/**
	 * The initial set of data to apply to the `tpl` to
	 * update the content area of the Component.
	 * 
	 */
	data?: any

	/**
	 * Whether or not this component is disabled
	 * 
	 */
	disabled?: boolean

	/**
	 * The dock position of this component in its container. Can be `left`, `top`, `right` or `bottom`.
	 * 
	 * __Notes__
	 * 
	 * You must use a HTML5 doctype for docked `bottom` to work. To do this, simply add the following code to the HTML file:
	 * 
	 *     <!doctype html>
	 * 
	 * So your index.html file should look a little like this:
	 * 
	 *     <!doctype html>
	 *     <html>
	 *         <head>
	 *             <title>MY application title</title>
	 *             ...
	 * 
	 */
	docked?: string

	/**
	 * Configuration options to make this Component draggable
	 * 
	 */
	draggable?: any

	/**
	 * The expand event(s) to listen for on each node.
	 * The node in question will be expanded, if collapsed,
	 * or collapsed, if expanded.
	 * `false` can be used to prevent listening for the default event.
	 * 
	 */
	expandEventName?: string | string[] | any

	/**
	 * CSS class that will be added to focused
	 * component's focusClsEl, and removed when component blurs.
	 * 
	 */
	focusCls?: string

	/**
	 * Force the component to take up 100% width and height available, by adding it
	 * to Ext.Viewport.
	 * 
	 */
	fullscreen?: boolean

	/**
	 * The height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	height?: number | string

	/**
	 * Whether or not this Component is hidden (its CSS `display` property is set to `none`).
	 * 
	 * Defaults to `true` for floated Components.
	 * 
	 */
	hidden?: boolean

	/**
	 * Animation effect to apply when the Component is being hidden.  Typically you want to use an
	 * outbound animation type such as 'fadeOut' or 'slideOut'. For more animations, check the Ext.fx.Animation#type config.
	 * 
	 */
	hideAnimation?: string | any

	/**
	 * When using a cfg!modal Component, setting this to `true`
	 * will hide the modal mask and the Container when the mask is tapped on.
	 * 
	 */
	hideOnMaskTap?: boolean

	/**
	 * The class name added to all hierarchy components (subclasses).
	 * See also componentCls.
	 * 
	 */
	hierarchyCls?: string

	/**
	 * Optional HTML content to render inside this Component, or a reference
	 * to an existing element on the page.
	 * 
	 */
	html?: string | any | HTMLElement

	/**
	 * The list of interaction configs for this D3 component.
	 * D3 package interactions are very similar to native D3 behaviors.
	 * However, D3 behaviors, as well as event system, is incompatible
	 * with ExtJS event system. D3 package interactions may also support
	 * certain features that D3 behaviors lack, like like kinetic scrolling,
	 * elastic borders and scroll indicators (see the Ext.d3.interaction.PanZoom
	 * interaction for more information).
	 * 
	 */
	interactions?: any[]

	/**
	 * An object containing handlers for keyboard events. The property names of this
	 * object are the key name and any modifiers. The values of the properties are the
	 * descriptors of how to handle each event.
	 * 
	 * The handler descriptor can be simply the handler function (either the
	 * literal function or the method name), or it can be an object with these
	 * properties:
	 * 
	 *  - `handler`: The function or its name to call to handle the event.
	 *  - `scope`: The this pointer context (can be "this" or "controller").
	 *  - `event`: An optional override of the key event to which to listen.
	 * 
	 * **Important:** Calls to `setKeyMap` do not replace the entire `keyMap` but
	 * instead update the provided mappings. That is, unless `null` is passed as the
	 * value of the `keyMap` which will clear the `keyMap` of all entries.
	 * 
	 */
	keyMap?: any

	/**
	 * Enables or disables processing keys in the `keyMap`. This value starts as
	 * `null` and if it is `null` when `initKeyMap` is called, it will automatically
	 * be set to `true`. Since `initKeyMap` is called by `Ext.Component` at the
	 * proper time, this is not something application code normally handles.
	 * 
	 */
	keyMapEnabled?: boolean

	/**
	 * The absolute left position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	left?: number | string

	/**
	 * The [key](https://github.com/d3/d3-selection/#selection_data) function for links.
	 * Returns the 'id' of the link's target Ext.data.TreeModel by default.
	 * 
	 */
	linkKey?: Function

	/**
	 * 
	 * A config object containing one or more event handlers to be added to this object during initialization. This
	 * should be a valid listeners config object as specified in the
	 * addListener example for attaching
	 * multiple handlers at once.
	 * 
	 * **DOM events from Ext JS Ext.Component**
	 * 
	 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
	 * only done when extra value can be added. For example the DataView's **`itemclick`** event passing the node clicked on. To access DOM events directly from a
	 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
	 * DOM listener to:
	 * 
	 *     new Ext.panel.Panel({
	 *         width: 400,
	 *         height: 200,
	 *         dockedItems: [{
	 *             xtype: 'toolbar'
	 *         }],
	 *         listeners: {
	 *             click: {
	 *                 element: 'el', //bind to the underlying el property on the panel
	 *                 fn: function(){ console.log('click el'); }
	 *             },
	 *             dblclick: {
	 *                 element: 'body', //bind to the underlying body property on the panel
	 *                 fn: function(){ console.log('dblclick body'); }
	 *             }
	 *         }
	 *     });
	 * 
	 */
	listeners?: any

	/**
	 * The margin to use on this Component. Can be specified as a number (in which case
	 * all edges get the same margin) or a CSS string like '5 10 10 10'
	 * 
	 */
	margin?: number | string

	/**
	 * The maximum height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * Note that this config will not apply if the Component is 'positioned' (absolutely positioned or centered)
	 * 
	 */
	maxHeight?: number | string

	/**
	 * The maximum width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * Note that this config will not apply if the Component is 'positioned' (absolutely positioned or centered)
	 * 
	 */
	maxWidth?: number | string

	/**
	 * The minimum height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	minHeight?: number | string

	/**
	 * The minimum width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	minWidth?: number | string

	/**
	 * `true` to make this Component modal. This will create a mask underneath the Component
	 * that covers its parent and does not allow the user to interact with any other Components until this
	 * Component is dismissed.
	 * 
	 */
	modal?: boolean

	/**
	 * Name for the widget to be used with Ext.Container#lookupName et al.
	 * 
	 */
	name?: string

	/**
	 * [Children](https://github.com/d3/d3-hierarchy/#hierarchy) accessor function.
	 * Defaults to returning node's nodes,
	 * if the node is expanded or null otherwise
	 * (meaning children of collapsed nodes are not rendered).
	 * 
	 */
	nodeChildren?: Function

	/**
	 * A function that updates class attributes of a given selection.
	 * By default adds the following classes to node elements:
	 * - `x-d3-parent` - if a node is a parent node;
	 * - `x-d3-leaf` - if a node is a leaf node;
	 * - `x-d3-expanded` - if a node is expanded;
	 * - `x-d3-root` - if a node is the root node (represents the root of the store);
	 * - `x-d3-layout-root` - if a node is the root node of the current layout.
	 * 
	 */
	nodeClass?: Function

	/**
	 * The [key](https://github.com/d3/d3-selection/#selection_data) function for nodes.
	 * Returns the 'id' of the node's Ext.data.TreeModel by default.
	 * 
	 */
	nodeKey?: Function

	/**
	 * The radius of the circle that represents a node.
	 * 
	 */
	nodeRadius?: number

	/**
	 * [Fixed size](https://github.com/mbostock/d3/wiki/Tree-Layout#nodeSize),
	 * of each node as a two-element array of numbers representing x and y.
	 * 
	 */
	nodeSize?: number[]

	/**
	 * A function that returns a text string, given a component and  node (d3.hierarchy) instance.
	 * Alternatively, can be a field name or an array of field names used to fetch the text.
	 * If array of field names is given, the first non-empty string will be used.
	 * A node holds a reference to the Ext.data.TreeModel instance
	 * in its `data` field.
	 * For example, to return the value of the record's field `name` as node's text
	 * the following function can be used:
	 * 
	 *     nodeText: function (component, node) {
	 *         var record = node.data,
	 *             text = record.get('name');
	 * 
	 *         return text;
	 *     }
	 * 
	 * Or simply:
	 * 
	 *     nodeText: 'name'
	 * 
	 * To return the value of the `title` field, if the `name` field is empty:
	 * 
	 *     nodeText: ['name', 'title']
	 * 
	 */
	nodeText?: Function | string | string[]

	/**
	 * [The function](https://github.com/d3/d3-hierarchy#node_sum) that receives
	 * the node's data (tree store record) and returns the numeric value of the node.
	 * This config can also be a field name or a number, in which case it will be
	 * converted to a function that returns the value of the specified field,
	 * or a function that returns the given number for all nodes.
	 * Note: nodeChildren does not have effect on this config, even
	 * though only expanded nodes will render by default, the `nodeValue`
	 * function will be called for all nodes.
	 * 
	 */
	nodeValue?: Function | string | number

	/**
	 * If `true` the nodeValue function will not be called for parent nodes,
	 * instead they'll get a value of zero.
	 * The nodeChildren function is used to determine if a node is a parent.
	 * 
	 */
	noParentValue?: boolean

	/**
	 * The padding of the scene.
	 * See Ext.util.Format#parseBox for syntax details,
	 * if using a string for this config.
	 * 
	 */
	padding?: any | string | number

	/**
	 * An object or array of objects that will provide custom functionality for this
	 * component. If a string is provided or a string is one of the elements of the
	 * array, that string is treated as the `type` alias. For example, "listpaging"
	 * is the type alias for `Ext.plugin.ListPaging`. The full alias includes the
	 * "plugin." prefix (i.e., 'plugin.listpaging').
	 * 
	 * Plugins should derive from `Ext.plugin.Abstract` but this is not required. The
	 * only requirement for a valid plugin is that it contain an `init()` method that
	 * accepts a reference to the owning component.
	 * 
	 * When a component is created, if any plugins are available, the component will
	 * call the `init` method on each plugin,
	 * passing a reference to itself. Each plugin can then call methods or respond to
	 * events on the component as needed to provide its functionality.
	 * 
	 * ## Example code
	 * 
	 * A plugin by alias:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: 'listpaging'
	 *      });
	 * 
	 * Multiple plugins by alias:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: ['listpaging', 'pullrefresh']
	 *      });
	 * 
	 * Single plugin by class name with config options:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: {
	 *              type: 'listpaging',
	 *              autoPaging: true
	 *          }
	 *      });
	 * 
	 * Multiple plugins by type and class name with config options:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: [{
	 *              xclass: 'Ext.plugin.PullRefresh',
	 *              pullRefreshText: 'Pull to refresh...'
	 *          }, {
	 *              type: 'listpaging',
	 *              autoPaging: true
	 *          }]
	 *      });
	 * 
	 */
	plugins?: any | string | any[] | string[]

	/**
	 * A model instance which updates the Component's html based on it's tpl. Similar to the data
	 * configuration, but tied to to a record to make allow dynamic updates.  This must be a model
	 * instance and not a configuration of one.
	 * 
	 */
	record?: any

	/**
	 * Optional element to render this Component to.
	 * Not required if this component is an item of a Container of a Container.
	 * 
	 */
	renderTo?: any

	/**
	 * The absolute right position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	right?: number | string

	/**
	 * False to hide the root node.
	 * 
	 */
	rootVisible?: boolean

	/**
	 * Configuration options to make this Component scrollable. Acceptable values are:
	 * 
	 * - `true` to enable auto scrolling.
	 * - `false` (or `null`) to disable scrolling - this is the default.
	 * - `x` or `horizontal` to enable horizontal scrolling only
	 * - `y` or `vertical` to enable vertical scrolling only
	 * 
	 * Also accepts a configuration object for a `Ext.scroll.Scroller` if
	 * if advanced configuration is needed.
	 * 
	 * The getter for this config returns the Ext.scroll.Scroller
	 * instance.  You can use the Scroller API to read or manipulate the scroll position:
	 * 
	 *     // scrolls the component to 5 on the x axis and 10 on the y axis
	 *     component.getScrollable().scrollTo(5, 10);
	 * 
	 */
	scrollable?: boolean | string | any

	/**
	 * The select event(s) to listen for on each node.
	 * The node in question will be selected,
	 * selection will be removed from the previously selected node.
	 * The select event won't be handled when Ctrl/Cmd is pressed.
	 * For example, this allows to expand a node by double-clicking
	 * without selecting it.
	 * `false` can be used to prevent listening for the default event.
	 * 
	 */
	selectEventName?: string | string[] | any

	/**
	 * The selected record. Typically used with binding.
	 * 
	 */
	selection?: any

	/**
	 * Animation effect to apply when the Component is being shown.  Typically you want to use an
	 * inbound animation type such as 'fadeIn' or 'slideIn'. For more animations, check the Ext.fx.Animation#type config.
	 * 
	 */
	showAnimation?: string | any

	/**
	 * Whether or not the component got its first size.
	 * Can be used in the `sceneresize` event handler to do user-defined setup on first
	 * resize, for example:
	 * 
	 *     listeners: {
	 *         sceneresize: function (component, scene, rect) {
	 *             if (!component.size) {
	 *                 // set things up
	 *             } else {
	 *                 // handle resize
	 *             }
	 *         }
	 *     }
	 * 
	 */
	size?: any

	/**
	 * The store with data to render.
	 * 
	 */
	store?: any

	/**
	 * Additional CSS styles that will be rendered into an inline style attribute when
	 * the widget is rendered.
	 * 
	 * You can pass either a string syntax:
	 * 
	 *     style: 'background:red'
	 * 
	 * Or by using an object:
	 * 
	 *     style: {
	 *         background: 'red'
	 *     }
	 * 
	 * When using the object syntax, you can define CSS Properties by using a string:
	 * 
	 *     style: {
	 *         'border-left': '1px solid red'
	 *     }
	 * 
	 * Although the object syntax is much easier to read, we suggest you to use the
	 * string syntax for better performance.
	 * 
	 */
	style?: string | any

	/**
	 * DOM tabIndex attribute for this component's focusEl.
	 * 
	 */
	tabIndex?: number

	/**
	 * The Ext.tip.ToolTip for this component.
	 * 
	 *     <Button text="Basic Tip">
	 *         <ToolTip>A simple tooltip</ToolTip>
	 *     </Button>
	 * 
	 */
	tooltip?: any

	/**
	 * The absolute top position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	top?: number | string

	/**
	 * 
	 * Emulates the behavior of the CSS [touch-action](https://www.w3.org/TR/pointerevents/#the-touch-action-css-property)
	 * property in a cross-browser compatible manner.
	 * 
	 * Keys in this object are touch action names, and values are `false` to disable
	 * a touch action or `true` to enable it.  Accepted keys are:
	 * 
	 * - `panX`
	 * - `panY`
	 * - `pinchZoom`
	 * - `doubleTapZoom`
	 * 
	 * All touch actions are enabled (`true`) by default, so it is usually only necessary
	 * to specify which touch actions to disable.  For example, the following disables
	 * only horizontal scrolling and pinch-to-zoom on the component's main element:
	 * 
	 *     touchAction: {
	 *         panX: false,
	 *         pinchZoom: false
	 *     }
	 * 
	 * Touch actions can be specified on reference elements using the reference element
	 * name, for example:
	 * 
	 *     // disables horizontal scrolling on the main element, and double-tap-zoom
	 *     // on the child element named "body"
	 *     touchAction: {
	 *         panY: false
	 *         body: {
	 *             doubleTapZoom: false
	 *         }
	 *     }
	 * 
	 * The primary motivation for setting the touch-action of an element is to prevent
	 * the browser's default handling of a gesture such as pinch-to-zoom, or
	 * drag-to-scroll, so that the application can implement its own handling of that
	 * gesture on the element.  Suppose, for example, a component has a custom drag
	 * handler on its element and wishes to prevent horizontal scrolling of its container
	 * while it is being dragged:
	 * 
	 *     Ext.create('Ext.Widget', {
	 *         touchAction: {
	 *             panX: false
	 *         },
	 *         listeners: {
	 *             drag: function(e) {
	 *                 // implement drag logic
	 *             }
	 *         }
	 *     });
	 * 
	 */
	touchAction?: any

	/**
	 * 
	 * A string, array of strings, or a function that returns JSX.
	 * 
	 *    tpl = data => <div>{data.first_name} {data.last_name}</div>
	 * 
	 * __Note__
	 * The data configuration _must_ be set for any content to be shown in the component when using this configuration.
	 * 
	 */
	tpl?: Function | string | string[]

	/**
	 * The Ext.(X)Template method to use when updating the content area of the Component.
	 * 
	 * Valid modes are:
	 * 
	 * - append
	 * - insertAfter
	 * - insertBefore
	 * - insertFirst
	 * - overwrite
	 * 
	 */
	tplWriteMode?: string

	/**
	 * A map of transition configs. For example:
	 * 
	 *     transitions: {
	 *         select: {
	 *             duration: 500,
	 *             ease: 'cubicInOut'
	 *         },
	 *         zoom: {
	 *             name: 'zoom',
	 *             duration: 1000
	 *         },
	 *         ...
	 *     }
	 * 
	 * A class would define the defaults for its transitions, and a user only needs
	 * to set the `transitions` config of an instance to disable a transition, e.g.:
	 * 
	 *     transitions: {
	 *         // transitions are enabled by default, `true` should never be used here
	 *         select: false
	 *     }
	 * 
	 * or alter its config:
	 * 
	 *     transitions: {
	 *         select: {
	 *             // the `duration` stays the same,
	 *             // only the easing function is altered
	 *             ease: 'bounceOut'
	 *         }
	 *     }
	 * 
	 * The transitions defined this way are merely configs. To create an actual transition
	 * from one of these configs, use the createTransition method. For example:
	 * 
	 *     this.createTransition('select')
	 * 
	 * A transition object can optionally specify a name, if it's different from
	 * the key in the `transitions` config. For example:
	 * 
	 *     transitions: {
	 *         layout: {
	 *             name: 'foo',
	 *             duration: 500
	 *         }
	 *     }
	 * 
	 * Otherwise the name will be set automatically, for example:
	 * 
	 *     transition.name = this.getId() + '-' + key
	 * 
	 * Transition names (whether explicitly given or not) are prefixed by component ID
	 * to prevent transitions with the same name but on a different component from
	 * cancelling each other out.
	 * 
	 * However, transitions with the same name on the same component will still cancel
	 * each other out, if created via createTransition on the same selection
	 * or with no selection provided.
	 * 
	 * `duration`, `ease` and `name` properties of transition objects in this config
	 * are reserved, and will be used to configure a `d3.transition` instance.
	 * However, transition objects may also have other properties that are related to
	 * this transition. For example:
	 * 
	 *     transitions: {
	 *         select: {
	 *             duration: 500,
	 *             ease: 'cubicInOut',
	 *             targetScale: 1.1
	 *         }
	 *     }
	 * 
	 * The `targetScale` property here won't be consumed by a `d3.transition` instance;
	 * instead a component can make use of it in whichever way it sees fit to animate
	 * the selected element.
	 * 
	 */
	transitions?: any

	/**
	 * The ui or uis to be used on this Component
	 * 
	 * When a ui is configured, CSS class names are added to the element, created
	 * by appending the ui name(s) to each classCls and/or baseCls.
	 * 
	 */
	ui?: string | string[]

	/**
	 * One or more CSS classes to add to the component's primary element. This config
	 * is intended solely for use by the component instantiator (the "user"), not by
	 * derived classes.
	 * 
	 * For example:
	 * 
	 *      items: [{
	 *          xtype: 'button',
	 *          userCls: 'my-button'
	 *      ...
	 *      }]
	 * 
	 */
	userCls?: string | string[]

	/**
	 * This value controls this item's order in a Ext.Container#cfg!weighted
	 * Ext.Container (see cfg!parent).
	 * 
	 * Lower values gravitate towards the start of the container - the top in vertical layouts, the
	 * locale start side in horizontal layouts.
	 * 
	 */
	weight?: number

	/**
	 * The width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	width?: number | string

	/**
	 * The z-index to give this Component when it is rendered.
	 * 
	 * Not valid for cfg-floated Components. The Z ordering of cfg-floated
	 * Components is managed by ordering of the DOM elements.
	 * 
	 */
	zIndex?: number

	/**
	 * Fires after a Component had been added to a Container.
	 * 
	 */
	onAdded?: (me: any, container: any, index: number) => void

	/**
	 * This event fires when `cfg!bottom` changes.
	 */
	onBeforeBottomChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!centered` changes.
	 */
	onBeforeCenteredChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!disabled` changes.
	 */
	onBeforeDisabledChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!docked` changes.
	 */
	onBeforeDockedChange?: (sender: any, value: string, oldValue: string) => void

	/**
	 * This event fires when `cfg!height` changes.
	 */
	onBeforeHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!hidden` changes.
	 */
	onBeforeHiddenChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires before the Component is hidden. Hide may be vetoed by returning `false` from a handler.
	 * 
	 */
	onBeforeHide?: (me: any) => void

	/**
	 * This event fires when `cfg!left` changes.
	 */
	onBeforeLeftChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxHeight` changes.
	 */
	onBeforeMaxHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxWidth` changes.
	 */
	onBeforeMaxWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minHeight` changes.
	 */
	onBeforeMinHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minWidth` changes.
	 */
	onBeforeMinWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!right` changes.
	 */
	onBeforeRightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!scrollable` changes.
	 */
	onBeforeScrollableChange?: (sender: any, value: boolean | string | any, oldValue: boolean | string | any) => void

	/**
	 * Fires before the Component is shown. Show may be vetoed by returning `false` from a handler.
	 * 
	 */
	onBeforeShow?: (me: any) => void

	/**
	 * This event fires when `cfg!top` changes.
	 */
	onBeforeTopChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!width` changes.
	 */
	onBeforeWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires when this Component's focusEl loses focus.
	 * 
	 */
	onBlur?: (me: any, event: any) => void

	/**
	 * This event fires when `cfg!bottom` changes.
	 */
	onBottomChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!centered` changes.
	 */
	onCenteredChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires when the component is destroyed
	 * 
	 */
	onDestroy?: () => void

	/**
	 * This event fires when `cfg!disabled` changes.
	 */
	onDisabledChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!docked` changes.
	 */
	onDockedChange?: (sender: any, value: string, oldValue: string) => void

	/**
	 * Fires when the component is no longer displayed in the DOM.  Listening to this event will
	 * degrade performance not recommend for general use.
	 * 
	 */
	onErased?: (me: any) => void

	/**
	 * Fires when this Component's focusEl receives focus.
	 * 
	 */
	onFocus?: (me: any, event: any) => void

	/**
	 * Fires when focus enters this Component's hierarchy.
	 * 
	 */
	onFocusEnter?: (me: any, event: any) => void

	/**
	 * Fires when focus leaves this Component's hierarchy.
	 * 
	 */
	onFocusLeave?: (me: any, event: any) => void

	/**
	 * Fires whenever a Component with the fullscreen config is instantiated
	 * 
	 */
	onFullscreen?: (me: any) => void

	/**
	 * This event fires when `cfg!height` changes.
	 */
	onHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!hidden` changes.
	 */
	onHiddenChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires whenever the Component is hidden
	 * 
	 */
	onHide?: (me: any) => void

	/**
	 * Fires when the component has been initialized
	 * 
	 */
	onInitialize?: (me: any) => void

	/**
	 * This event fires when `cfg!left` changes.
	 */
	onLeftChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxHeight` changes.
	 */
	onMaxHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxWidth` changes.
	 */
	onMaxWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minHeight` changes.
	 */
	onMinHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minWidth` changes.
	 */
	onMinWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires when a component si moved within its Container.
	 * 
	 */
	onMoved?: (me: any, container: any, toIndex: number, fromIndex: number) => void

	/**
	 * Fires whenever this Element actually becomes visible (painted) on the screen. This is useful when you need to
	 * perform 'read' operations on the DOM element, i.e: calculating natural sizes and positioning.
	 * 
	 * __Note:__ This event is not available to be used with event delegation. Instead `painted` only fires if you explicitly
	 * add at least one listener to it, for performance reasons.
	 * 
	 */
	onPainted?: (element: any) => void

	/**
	 * Fires whenever there is a change in the positioned status of a component
	 * 
	 */
	onPositionedChange?: (me: any, positioned: boolean) => void

	/**
	 * Fires when a component is removed from a Container
	 * 
	 */
	onRemoved?: (me: any, container: any, index: number) => void

	/**
	 * Fires *asynchronously* after a browser layout caused by a component resize. This may be triggered for any or
	 * several of the following reasons:
	 *    - Programmatic changes to cfg-width or cfg-height configs.
	 *    - Setting the cfg-flex config when the owning layout is Ext.layout.Box.
	 *    - Setting cfg-minHeight, cfg-maxHeight, cfg-minWidth or cfg-maxWidth.
	 *    - Changing device orientation.
	 *    - Changing the browser viewport size.
	 *    - Any resize caused by browser layout recalculation which may be caused by content size changes
	 *      or application of default browser layout rules.
	 * 
	 */
	onResize?: (component: any, width: string | number, height: string | number, oldWidth: string | number, oldHeight: string | number) => void

	/**
	 * This event fires when `cfg!right` changes.
	 */
	onRightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires after scene size has changed.
	 * Notes: the scene is a 'g' element, so it cannot actually have a size.
	 * The size reported is the size the drawing is supposed to fit in.
	 * 
	 */
	onSceneResize?: (component: any, scene: any, size: any) => void

	/**
	 * Fires once after the scene has been created.
	 * Note that at this time the component doesn't have a size yet.
	 * 
	 */
	onSceneSetup?: (component: any, scene: any) => void

	/**
	 * This event fires when `cfg!scrollable` changes.
	 */
	onScrollableChange?: (sender: any, value: boolean | string | any, oldValue: boolean | string | any) => void

	/**
	 * Fires whenever the Component is shown
	 * 
	 */
	onShow?: (me: any) => void

	/**
	 * This event fires when `cfg!top` changes.
	 */
	onTopChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!width` changes.
	 */
	onWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void
}

/**
 * 
 * The 'd3-horizontal-tree' component is a perfect way to visualize hierarchical
 * data as an actual tree in case where the relative size of nodes is of little
 * interest, and the focus is on the relative position of each node in the hierarchy.
 * A horizontal tree makes for a more consistent look and more efficient use of space
 * when text labels are shown next to each node.
 * 
 */
declare class D3_Horizontal_Tree extends React.Component<D3_Horizontal_TreeProps, any> { }
export interface D3_Horizontal_TreeProps extends FlexibleProps {

	/**
	 * An object containing ARIA attributes to be set
	 * on this Component's ARIA element. Use this to set the attributes that cannot be
	 * determined by the Component's state, such as `aria-live`, `aria-flowto`, etc.
	 * 
	 * **Note** that this config is only meaningful at the Component rendering time,
	 * and setting it after that will do nothing.
	 * 
	 */
	ariaAttributes?: any

	/**
	 * DOM selector for a child element that is to be used
	 * as description for this Component, set in `aria-describedby` attribute.
	 * The selector works the same way as ariaLabelledBy.
	 * 
	 */
	ariaDescribedBy?: string

	/**
	 * ARIA label for this Component. It is best to use
	 * ariaLabelledBy option instead, because screen readers prefer
	 * `aria-labelledby` attribute to `aria-label`. ariaLabel and
	 * ariaLabelledBy config options are mutually exclusive.
	 * 
	 */
	ariaLabel?: string

	/**
	 * DOM selector for a child element that is to be used
	 * as label for this Component, set in `aria-labelledby` attribute.
	 * If the selector is by `#id`, the label element can be any existing element,
	 * not necessarily a child of the main Component element.
	 * 
	 * ariaLabelledBy and ariaLabel config options are
	 * mutually exclusive, and `ariaLabelledBy` has the higher precedence.
	 * 
	 */
	ariaLabelledBy?: string

	/**
	 * If `true`, then, when showBy or alignTo fallback on
	 * constraint violation only takes place along the major align axis.
	 * 
	 * That is, if alignment `"l-r"` is being used, and `axisLock: true` is used, then if constraints
	 * fail, only fallback to `"r-l"` is considered.
	 * 
	 */
	axisLock?: boolean

	/**
	 * 
	 * Enables or disables bordering on this component.
	 * The following values are accepted:
	 * 
	 * - `null` or `true (default): Do nothing and allow the border to be specified by the theme.
	 * - `false`: suppress the default border provided by the theme.
	 * 
	 * Please note that enabling bordering via this config will not add a `border-color`
	 * or `border-style` CSS property to the component; you provide the `border-color`
	 * and `border-style` via CSS rule or style configuration
	 * (if not already provide by the theme).
	 * 
	 */
	border?: boolean

	/**
	 * The absolute bottom position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	bottom?: number | string

	/**
	 * Configure this as `true` to have this Component centered within its Container.
	 * Setting this value to `true` will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	centered?: boolean

	/**
	 * If the scene elements that go outside the scene and into the padding area
	 * should be clipped.
	 * Note: stock D3 components are not designed to work with this config set to `true`.
	 * 
	 */
	clipScene?: boolean

	/**
	 * The CSS class to add to this widget's element, in
	 * addition to the baseCls. In many cases, this property will be specified
	 * by the derived widget class. See userCls for adding additional CSS
	 * classes to widget instances (such as items in a Ext.Container).
	 * 
	 */
	cls?: string | string[]

	/**
	 * A Ext.d3.axis.Color config or an instance.
	 * By default (if no 'colorAxis' config is given) all nodes
	 * are assigned a unique color from the `d3.scale.category20c`
	 * scale (until the colors run out, then we start to reuse them)
	 * based on the value of the `name` field.
	 * 
	 */
	colorAxis?: any

	/**
	 * The CSS class used by a subclass of the D3 Component.
	 * Normally, the lower-cased name of a subclass.
	 * 
	 */
	componentCls?: string

	/**
	 * The configured element will automatically be
	 * added as the content of this component. When you pass a string, we expect it to be an element id.
	 * If the content element is hidden, we will automatically show it.
	 * 
	 */
	contentEl?: any | HTMLElement | string

	/**
	 * The initial set of data to apply to the `tpl` to
	 * update the content area of the Component.
	 * 
	 */
	data?: any

	/**
	 * Whether or not this component is disabled
	 * 
	 */
	disabled?: boolean

	/**
	 * The dock position of this component in its container. Can be `left`, `top`, `right` or `bottom`.
	 * 
	 * __Notes__
	 * 
	 * You must use a HTML5 doctype for docked `bottom` to work. To do this, simply add the following code to the HTML file:
	 * 
	 *     <!doctype html>
	 * 
	 * So your index.html file should look a little like this:
	 * 
	 *     <!doctype html>
	 *     <html>
	 *         <head>
	 *             <title>MY application title</title>
	 *             ...
	 * 
	 */
	docked?: string

	/**
	 * Configuration options to make this Component draggable
	 * 
	 */
	draggable?: any

	/**
	 * The expand event(s) to listen for on each node.
	 * The node in question will be expanded, if collapsed,
	 * or collapsed, if expanded.
	 * `false` can be used to prevent listening for the default event.
	 * 
	 */
	expandEventName?: string | string[] | any

	/**
	 * CSS class that will be added to focused
	 * component's focusClsEl, and removed when component blurs.
	 * 
	 */
	focusCls?: string

	/**
	 * Force the component to take up 100% width and height available, by adding it
	 * to Ext.Viewport.
	 * 
	 */
	fullscreen?: boolean

	/**
	 * The height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	height?: number | string

	/**
	 * Whether or not this Component is hidden (its CSS `display` property is set to `none`).
	 * 
	 * Defaults to `true` for floated Components.
	 * 
	 */
	hidden?: boolean

	/**
	 * Animation effect to apply when the Component is being hidden.  Typically you want to use an
	 * outbound animation type such as 'fadeOut' or 'slideOut'. For more animations, check the Ext.fx.Animation#type config.
	 * 
	 */
	hideAnimation?: string | any

	/**
	 * When using a cfg!modal Component, setting this to `true`
	 * will hide the modal mask and the Container when the mask is tapped on.
	 * 
	 */
	hideOnMaskTap?: boolean

	/**
	 * The class name added to all hierarchy components (subclasses).
	 * See also componentCls.
	 * 
	 */
	hierarchyCls?: string

	/**
	 * Optional HTML content to render inside this Component, or a reference
	 * to an existing element on the page.
	 * 
	 */
	html?: string | any | HTMLElement

	/**
	 * The list of interaction configs for this D3 component.
	 * D3 package interactions are very similar to native D3 behaviors.
	 * However, D3 behaviors, as well as event system, is incompatible
	 * with ExtJS event system. D3 package interactions may also support
	 * certain features that D3 behaviors lack, like like kinetic scrolling,
	 * elastic borders and scroll indicators (see the Ext.d3.interaction.PanZoom
	 * interaction for more information).
	 * 
	 */
	interactions?: any[]

	/**
	 * An object containing handlers for keyboard events. The property names of this
	 * object are the key name and any modifiers. The values of the properties are the
	 * descriptors of how to handle each event.
	 * 
	 * The handler descriptor can be simply the handler function (either the
	 * literal function or the method name), or it can be an object with these
	 * properties:
	 * 
	 *  - `handler`: The function or its name to call to handle the event.
	 *  - `scope`: The this pointer context (can be "this" or "controller").
	 *  - `event`: An optional override of the key event to which to listen.
	 * 
	 * **Important:** Calls to `setKeyMap` do not replace the entire `keyMap` but
	 * instead update the provided mappings. That is, unless `null` is passed as the
	 * value of the `keyMap` which will clear the `keyMap` of all entries.
	 * 
	 */
	keyMap?: any

	/**
	 * Enables or disables processing keys in the `keyMap`. This value starts as
	 * `null` and if it is `null` when `initKeyMap` is called, it will automatically
	 * be set to `true`. Since `initKeyMap` is called by `Ext.Component` at the
	 * proper time, this is not something application code normally handles.
	 * 
	 */
	keyMapEnabled?: boolean

	/**
	 * The absolute left position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	left?: number | string

	/**
	 * The [key](https://github.com/d3/d3-selection/#selection_data) function for links.
	 * Returns the 'id' of the link's target Ext.data.TreeModel by default.
	 * 
	 */
	linkKey?: Function

	/**
	 * 
	 * A config object containing one or more event handlers to be added to this object during initialization. This
	 * should be a valid listeners config object as specified in the
	 * addListener example for attaching
	 * multiple handlers at once.
	 * 
	 * **DOM events from Ext JS Ext.Component**
	 * 
	 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
	 * only done when extra value can be added. For example the DataView's **`itemclick`** event passing the node clicked on. To access DOM events directly from a
	 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
	 * DOM listener to:
	 * 
	 *     new Ext.panel.Panel({
	 *         width: 400,
	 *         height: 200,
	 *         dockedItems: [{
	 *             xtype: 'toolbar'
	 *         }],
	 *         listeners: {
	 *             click: {
	 *                 element: 'el', //bind to the underlying el property on the panel
	 *                 fn: function(){ console.log('click el'); }
	 *             },
	 *             dblclick: {
	 *                 element: 'body', //bind to the underlying body property on the panel
	 *                 fn: function(){ console.log('dblclick body'); }
	 *             }
	 *         }
	 *     });
	 * 
	 */
	listeners?: any

	/**
	 * The margin to use on this Component. Can be specified as a number (in which case
	 * all edges get the same margin) or a CSS string like '5 10 10 10'
	 * 
	 */
	margin?: number | string

	/**
	 * The maximum height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * Note that this config will not apply if the Component is 'positioned' (absolutely positioned or centered)
	 * 
	 */
	maxHeight?: number | string

	/**
	 * The maximum width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * Note that this config will not apply if the Component is 'positioned' (absolutely positioned or centered)
	 * 
	 */
	maxWidth?: number | string

	/**
	 * The minimum height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	minHeight?: number | string

	/**
	 * The minimum width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	minWidth?: number | string

	/**
	 * `true` to make this Component modal. This will create a mask underneath the Component
	 * that covers its parent and does not allow the user to interact with any other Components until this
	 * Component is dismissed.
	 * 
	 */
	modal?: boolean

	/**
	 * Name for the widget to be used with Ext.Container#lookupName et al.
	 * 
	 */
	name?: string

	/**
	 * [Children](https://github.com/d3/d3-hierarchy/#hierarchy) accessor function.
	 * Defaults to returning node's nodes,
	 * if the node is expanded or null otherwise
	 * (meaning children of collapsed nodes are not rendered).
	 * 
	 */
	nodeChildren?: Function

	/**
	 * A function that updates class attributes of a given selection.
	 * By default adds the following classes to node elements:
	 * - `x-d3-parent` - if a node is a parent node;
	 * - `x-d3-leaf` - if a node is a leaf node;
	 * - `x-d3-expanded` - if a node is expanded;
	 * - `x-d3-root` - if a node is the root node (represents the root of the store);
	 * - `x-d3-layout-root` - if a node is the root node of the current layout.
	 * 
	 */
	nodeClass?: Function

	/**
	 * The [key](https://github.com/d3/d3-selection/#selection_data) function for nodes.
	 * Returns the 'id' of the node's Ext.data.TreeModel by default.
	 * 
	 */
	nodeKey?: Function

	/**
	 * The radius of the circle that represents a node.
	 * 
	 */
	nodeRadius?: number

	/**
	 * [Fixed size](https://github.com/mbostock/d3/wiki/Tree-Layout#nodeSize),
	 * of each node as a two-element array of numbers representing x and y.
	 * 
	 */
	nodeSize?: number[]

	/**
	 * A function that returns a text string, given a component and  node (d3.hierarchy) instance.
	 * Alternatively, can be a field name or an array of field names used to fetch the text.
	 * If array of field names is given, the first non-empty string will be used.
	 * A node holds a reference to the Ext.data.TreeModel instance
	 * in its `data` field.
	 * For example, to return the value of the record's field `name` as node's text
	 * the following function can be used:
	 * 
	 *     nodeText: function (component, node) {
	 *         var record = node.data,
	 *             text = record.get('name');
	 * 
	 *         return text;
	 *     }
	 * 
	 * Or simply:
	 * 
	 *     nodeText: 'name'
	 * 
	 * To return the value of the `title` field, if the `name` field is empty:
	 * 
	 *     nodeText: ['name', 'title']
	 * 
	 */
	nodeText?: Function | string | string[]

	/**
	 * [The function](https://github.com/d3/d3-hierarchy#node_sum) that receives
	 * the node's data (tree store record) and returns the numeric value of the node.
	 * This config can also be a field name or a number, in which case it will be
	 * converted to a function that returns the value of the specified field,
	 * or a function that returns the given number for all nodes.
	 * Note: nodeChildren does not have effect on this config, even
	 * though only expanded nodes will render by default, the `nodeValue`
	 * function will be called for all nodes.
	 * 
	 */
	nodeValue?: Function | string | number

	/**
	 * If `true` the nodeValue function will not be called for parent nodes,
	 * instead they'll get a value of zero.
	 * The nodeChildren function is used to determine if a node is a parent.
	 * 
	 */
	noParentValue?: boolean

	/**
	 * The padding of the scene.
	 * See Ext.util.Format#parseBox for syntax details,
	 * if using a string for this config.
	 * 
	 */
	padding?: any | string | number

	/**
	 * An object or array of objects that will provide custom functionality for this
	 * component. If a string is provided or a string is one of the elements of the
	 * array, that string is treated as the `type` alias. For example, "listpaging"
	 * is the type alias for `Ext.plugin.ListPaging`. The full alias includes the
	 * "plugin." prefix (i.e., 'plugin.listpaging').
	 * 
	 * Plugins should derive from `Ext.plugin.Abstract` but this is not required. The
	 * only requirement for a valid plugin is that it contain an `init()` method that
	 * accepts a reference to the owning component.
	 * 
	 * When a component is created, if any plugins are available, the component will
	 * call the `init` method on each plugin,
	 * passing a reference to itself. Each plugin can then call methods or respond to
	 * events on the component as needed to provide its functionality.
	 * 
	 * ## Example code
	 * 
	 * A plugin by alias:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: 'listpaging'
	 *      });
	 * 
	 * Multiple plugins by alias:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: ['listpaging', 'pullrefresh']
	 *      });
	 * 
	 * Single plugin by class name with config options:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: {
	 *              type: 'listpaging',
	 *              autoPaging: true
	 *          }
	 *      });
	 * 
	 * Multiple plugins by type and class name with config options:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: [{
	 *              xclass: 'Ext.plugin.PullRefresh',
	 *              pullRefreshText: 'Pull to refresh...'
	 *          }, {
	 *              type: 'listpaging',
	 *              autoPaging: true
	 *          }]
	 *      });
	 * 
	 */
	plugins?: any | string | any[] | string[]

	/**
	 * A model instance which updates the Component's html based on it's tpl. Similar to the data
	 * configuration, but tied to to a record to make allow dynamic updates.  This must be a model
	 * instance and not a configuration of one.
	 * 
	 */
	record?: any

	/**
	 * Optional element to render this Component to.
	 * Not required if this component is an item of a Container of a Container.
	 * 
	 */
	renderTo?: any

	/**
	 * The absolute right position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	right?: number | string

	/**
	 * False to hide the root node.
	 * 
	 */
	rootVisible?: boolean

	/**
	 * Configuration options to make this Component scrollable. Acceptable values are:
	 * 
	 * - `true` to enable auto scrolling.
	 * - `false` (or `null`) to disable scrolling - this is the default.
	 * - `x` or `horizontal` to enable horizontal scrolling only
	 * - `y` or `vertical` to enable vertical scrolling only
	 * 
	 * Also accepts a configuration object for a `Ext.scroll.Scroller` if
	 * if advanced configuration is needed.
	 * 
	 * The getter for this config returns the Ext.scroll.Scroller
	 * instance.  You can use the Scroller API to read or manipulate the scroll position:
	 * 
	 *     // scrolls the component to 5 on the x axis and 10 on the y axis
	 *     component.getScrollable().scrollTo(5, 10);
	 * 
	 */
	scrollable?: boolean | string | any

	/**
	 * The select event(s) to listen for on each node.
	 * The node in question will be selected,
	 * selection will be removed from the previously selected node.
	 * The select event won't be handled when Ctrl/Cmd is pressed.
	 * For example, this allows to expand a node by double-clicking
	 * without selecting it.
	 * `false` can be used to prevent listening for the default event.
	 * 
	 */
	selectEventName?: string | string[] | any

	/**
	 * The selected record. Typically used with binding.
	 * 
	 */
	selection?: any

	/**
	 * Animation effect to apply when the Component is being shown.  Typically you want to use an
	 * inbound animation type such as 'fadeIn' or 'slideIn'. For more animations, check the Ext.fx.Animation#type config.
	 * 
	 */
	showAnimation?: string | any

	/**
	 * Whether or not the component got its first size.
	 * Can be used in the `sceneresize` event handler to do user-defined setup on first
	 * resize, for example:
	 * 
	 *     listeners: {
	 *         sceneresize: function (component, scene, rect) {
	 *             if (!component.size) {
	 *                 // set things up
	 *             } else {
	 *                 // handle resize
	 *             }
	 *         }
	 *     }
	 * 
	 */
	size?: any

	/**
	 * The store with data to render.
	 * 
	 */
	store?: any

	/**
	 * Additional CSS styles that will be rendered into an inline style attribute when
	 * the widget is rendered.
	 * 
	 * You can pass either a string syntax:
	 * 
	 *     style: 'background:red'
	 * 
	 * Or by using an object:
	 * 
	 *     style: {
	 *         background: 'red'
	 *     }
	 * 
	 * When using the object syntax, you can define CSS Properties by using a string:
	 * 
	 *     style: {
	 *         'border-left': '1px solid red'
	 *     }
	 * 
	 * Although the object syntax is much easier to read, we suggest you to use the
	 * string syntax for better performance.
	 * 
	 */
	style?: string | any

	/**
	 * DOM tabIndex attribute for this component's focusEl.
	 * 
	 */
	tabIndex?: number

	/**
	 * The Ext.tip.ToolTip for this component.
	 * 
	 *     <Button text="Basic Tip">
	 *         <ToolTip>A simple tooltip</ToolTip>
	 *     </Button>
	 * 
	 */
	tooltip?: any

	/**
	 * The absolute top position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	top?: number | string

	/**
	 * 
	 * Emulates the behavior of the CSS [touch-action](https://www.w3.org/TR/pointerevents/#the-touch-action-css-property)
	 * property in a cross-browser compatible manner.
	 * 
	 * Keys in this object are touch action names, and values are `false` to disable
	 * a touch action or `true` to enable it.  Accepted keys are:
	 * 
	 * - `panX`
	 * - `panY`
	 * - `pinchZoom`
	 * - `doubleTapZoom`
	 * 
	 * All touch actions are enabled (`true`) by default, so it is usually only necessary
	 * to specify which touch actions to disable.  For example, the following disables
	 * only horizontal scrolling and pinch-to-zoom on the component's main element:
	 * 
	 *     touchAction: {
	 *         panX: false,
	 *         pinchZoom: false
	 *     }
	 * 
	 * Touch actions can be specified on reference elements using the reference element
	 * name, for example:
	 * 
	 *     // disables horizontal scrolling on the main element, and double-tap-zoom
	 *     // on the child element named "body"
	 *     touchAction: {
	 *         panY: false
	 *         body: {
	 *             doubleTapZoom: false
	 *         }
	 *     }
	 * 
	 * The primary motivation for setting the touch-action of an element is to prevent
	 * the browser's default handling of a gesture such as pinch-to-zoom, or
	 * drag-to-scroll, so that the application can implement its own handling of that
	 * gesture on the element.  Suppose, for example, a component has a custom drag
	 * handler on its element and wishes to prevent horizontal scrolling of its container
	 * while it is being dragged:
	 * 
	 *     Ext.create('Ext.Widget', {
	 *         touchAction: {
	 *             panX: false
	 *         },
	 *         listeners: {
	 *             drag: function(e) {
	 *                 // implement drag logic
	 *             }
	 *         }
	 *     });
	 * 
	 */
	touchAction?: any

	/**
	 * 
	 * A string, array of strings, or a function that returns JSX.
	 * 
	 *    tpl = data => <div>{data.first_name} {data.last_name}</div>
	 * 
	 * __Note__
	 * The data configuration _must_ be set for any content to be shown in the component when using this configuration.
	 * 
	 */
	tpl?: Function | string | string[]

	/**
	 * The Ext.(X)Template method to use when updating the content area of the Component.
	 * 
	 * Valid modes are:
	 * 
	 * - append
	 * - insertAfter
	 * - insertBefore
	 * - insertFirst
	 * - overwrite
	 * 
	 */
	tplWriteMode?: string

	/**
	 * A map of transition configs. For example:
	 * 
	 *     transitions: {
	 *         select: {
	 *             duration: 500,
	 *             ease: 'cubicInOut'
	 *         },
	 *         zoom: {
	 *             name: 'zoom',
	 *             duration: 1000
	 *         },
	 *         ...
	 *     }
	 * 
	 * A class would define the defaults for its transitions, and a user only needs
	 * to set the `transitions` config of an instance to disable a transition, e.g.:
	 * 
	 *     transitions: {
	 *         // transitions are enabled by default, `true` should never be used here
	 *         select: false
	 *     }
	 * 
	 * or alter its config:
	 * 
	 *     transitions: {
	 *         select: {
	 *             // the `duration` stays the same,
	 *             // only the easing function is altered
	 *             ease: 'bounceOut'
	 *         }
	 *     }
	 * 
	 * The transitions defined this way are merely configs. To create an actual transition
	 * from one of these configs, use the createTransition method. For example:
	 * 
	 *     this.createTransition('select')
	 * 
	 * A transition object can optionally specify a name, if it's different from
	 * the key in the `transitions` config. For example:
	 * 
	 *     transitions: {
	 *         layout: {
	 *             name: 'foo',
	 *             duration: 500
	 *         }
	 *     }
	 * 
	 * Otherwise the name will be set automatically, for example:
	 * 
	 *     transition.name = this.getId() + '-' + key
	 * 
	 * Transition names (whether explicitly given or not) are prefixed by component ID
	 * to prevent transitions with the same name but on a different component from
	 * cancelling each other out.
	 * 
	 * However, transitions with the same name on the same component will still cancel
	 * each other out, if created via createTransition on the same selection
	 * or with no selection provided.
	 * 
	 * `duration`, `ease` and `name` properties of transition objects in this config
	 * are reserved, and will be used to configure a `d3.transition` instance.
	 * However, transition objects may also have other properties that are related to
	 * this transition. For example:
	 * 
	 *     transitions: {
	 *         select: {
	 *             duration: 500,
	 *             ease: 'cubicInOut',
	 *             targetScale: 1.1
	 *         }
	 *     }
	 * 
	 * The `targetScale` property here won't be consumed by a `d3.transition` instance;
	 * instead a component can make use of it in whichever way it sees fit to animate
	 * the selected element.
	 * 
	 */
	transitions?: any

	/**
	 * The ui or uis to be used on this Component
	 * 
	 * When a ui is configured, CSS class names are added to the element, created
	 * by appending the ui name(s) to each classCls and/or baseCls.
	 * 
	 */
	ui?: string | string[]

	/**
	 * One or more CSS classes to add to the component's primary element. This config
	 * is intended solely for use by the component instantiator (the "user"), not by
	 * derived classes.
	 * 
	 * For example:
	 * 
	 *      items: [{
	 *          xtype: 'button',
	 *          userCls: 'my-button'
	 *      ...
	 *      }]
	 * 
	 */
	userCls?: string | string[]

	/**
	 * This value controls this item's order in a Ext.Container#cfg!weighted
	 * Ext.Container (see cfg!parent).
	 * 
	 * Lower values gravitate towards the start of the container - the top in vertical layouts, the
	 * locale start side in horizontal layouts.
	 * 
	 */
	weight?: number

	/**
	 * The width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	width?: number | string

	/**
	 * The z-index to give this Component when it is rendered.
	 * 
	 * Not valid for cfg-floated Components. The Z ordering of cfg-floated
	 * Components is managed by ordering of the DOM elements.
	 * 
	 */
	zIndex?: number

	/**
	 * Fires after a Component had been added to a Container.
	 * 
	 */
	onAdded?: (me: any, container: any, index: number) => void

	/**
	 * This event fires when `cfg!bottom` changes.
	 */
	onBeforeBottomChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!centered` changes.
	 */
	onBeforeCenteredChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!disabled` changes.
	 */
	onBeforeDisabledChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!docked` changes.
	 */
	onBeforeDockedChange?: (sender: any, value: string, oldValue: string) => void

	/**
	 * This event fires when `cfg!height` changes.
	 */
	onBeforeHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!hidden` changes.
	 */
	onBeforeHiddenChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires before the Component is hidden. Hide may be vetoed by returning `false` from a handler.
	 * 
	 */
	onBeforeHide?: (me: any) => void

	/**
	 * This event fires when `cfg!left` changes.
	 */
	onBeforeLeftChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxHeight` changes.
	 */
	onBeforeMaxHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxWidth` changes.
	 */
	onBeforeMaxWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minHeight` changes.
	 */
	onBeforeMinHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minWidth` changes.
	 */
	onBeforeMinWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!right` changes.
	 */
	onBeforeRightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!scrollable` changes.
	 */
	onBeforeScrollableChange?: (sender: any, value: boolean | string | any, oldValue: boolean | string | any) => void

	/**
	 * Fires before the Component is shown. Show may be vetoed by returning `false` from a handler.
	 * 
	 */
	onBeforeShow?: (me: any) => void

	/**
	 * This event fires when `cfg!top` changes.
	 */
	onBeforeTopChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!width` changes.
	 */
	onBeforeWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires when this Component's focusEl loses focus.
	 * 
	 */
	onBlur?: (me: any, event: any) => void

	/**
	 * This event fires when `cfg!bottom` changes.
	 */
	onBottomChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!centered` changes.
	 */
	onCenteredChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires when the component is destroyed
	 * 
	 */
	onDestroy?: () => void

	/**
	 * This event fires when `cfg!disabled` changes.
	 */
	onDisabledChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!docked` changes.
	 */
	onDockedChange?: (sender: any, value: string, oldValue: string) => void

	/**
	 * Fires when the component is no longer displayed in the DOM.  Listening to this event will
	 * degrade performance not recommend for general use.
	 * 
	 */
	onErased?: (me: any) => void

	/**
	 * Fires when this Component's focusEl receives focus.
	 * 
	 */
	onFocus?: (me: any, event: any) => void

	/**
	 * Fires when focus enters this Component's hierarchy.
	 * 
	 */
	onFocusEnter?: (me: any, event: any) => void

	/**
	 * Fires when focus leaves this Component's hierarchy.
	 * 
	 */
	onFocusLeave?: (me: any, event: any) => void

	/**
	 * Fires whenever a Component with the fullscreen config is instantiated
	 * 
	 */
	onFullscreen?: (me: any) => void

	/**
	 * This event fires when `cfg!height` changes.
	 */
	onHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!hidden` changes.
	 */
	onHiddenChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires whenever the Component is hidden
	 * 
	 */
	onHide?: (me: any) => void

	/**
	 * Fires when the component has been initialized
	 * 
	 */
	onInitialize?: (me: any) => void

	/**
	 * This event fires when `cfg!left` changes.
	 */
	onLeftChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxHeight` changes.
	 */
	onMaxHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxWidth` changes.
	 */
	onMaxWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minHeight` changes.
	 */
	onMinHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minWidth` changes.
	 */
	onMinWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires when a component si moved within its Container.
	 * 
	 */
	onMoved?: (me: any, container: any, toIndex: number, fromIndex: number) => void

	/**
	 * Fires whenever this Element actually becomes visible (painted) on the screen. This is useful when you need to
	 * perform 'read' operations on the DOM element, i.e: calculating natural sizes and positioning.
	 * 
	 * __Note:__ This event is not available to be used with event delegation. Instead `painted` only fires if you explicitly
	 * add at least one listener to it, for performance reasons.
	 * 
	 */
	onPainted?: (element: any) => void

	/**
	 * Fires whenever there is a change in the positioned status of a component
	 * 
	 */
	onPositionedChange?: (me: any, positioned: boolean) => void

	/**
	 * Fires when a component is removed from a Container
	 * 
	 */
	onRemoved?: (me: any, container: any, index: number) => void

	/**
	 * Fires *asynchronously* after a browser layout caused by a component resize. This may be triggered for any or
	 * several of the following reasons:
	 *    - Programmatic changes to cfg-width or cfg-height configs.
	 *    - Setting the cfg-flex config when the owning layout is Ext.layout.Box.
	 *    - Setting cfg-minHeight, cfg-maxHeight, cfg-minWidth or cfg-maxWidth.
	 *    - Changing device orientation.
	 *    - Changing the browser viewport size.
	 *    - Any resize caused by browser layout recalculation which may be caused by content size changes
	 *      or application of default browser layout rules.
	 * 
	 */
	onResize?: (component: any, width: string | number, height: string | number, oldWidth: string | number, oldHeight: string | number) => void

	/**
	 * This event fires when `cfg!right` changes.
	 */
	onRightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires after scene size has changed.
	 * Notes: the scene is a 'g' element, so it cannot actually have a size.
	 * The size reported is the size the drawing is supposed to fit in.
	 * 
	 */
	onSceneResize?: (component: any, scene: any, size: any) => void

	/**
	 * Fires once after the scene has been created.
	 * Note that at this time the component doesn't have a size yet.
	 * 
	 */
	onSceneSetup?: (component: any, scene: any) => void

	/**
	 * This event fires when `cfg!scrollable` changes.
	 */
	onScrollableChange?: (sender: any, value: boolean | string | any, oldValue: boolean | string | any) => void

	/**
	 * Fires whenever the Component is shown
	 * 
	 */
	onShow?: (me: any) => void

	/**
	 * This event fires when `cfg!top` changes.
	 */
	onTopChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!width` changes.
	 */
	onWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void
}

/**
 * 
 * The 'd3-treemap' component uses D3's
 * [TreeMap Layout](https://github.com/d3/d3-hierarchy/#treemap)
 * to recursively subdivide area into rectangles, where the area of any node in the tree
 * corresponds to its value.
 * 
 *     @example packages=[d3,reactor]
 *     import React, { Component } from 'react'
 *     import { Container }  from '@extjs/ext-react';
 *     import { D3_TreeMap } from '@extjs/ext-react-d3';
 * 
 *     export default class MyExample extends Component {
 * 
 *         store = Ext.create('Ext.data.TreeStore', {
 *                 data: [{
 *                     text: 'Hulk',
 *                     value: 5,
 *                     children: [{
 *                         text: 'The Leader',
 *                         value: 3
 *                     },
 *                         {
 *                             text: 'Abomination',
 *                             value: 2
 *                         },
 *                         {
 *                             text: 'Sandman',
 *                             value: 1
 *                         }
 *                     ]
 *                 },
 *                     {
 *                         text: 'Vision',
 *                         value: 4,
 *                         children: [{
 *                             text: 'Kang',
 *                             value: 4
 *                         },
 *                             {
 *                                 text: 'Magneto',
 *                                 value: 3
 *                             },
 *                             {
 *                                 text: 'Norman Osborn',
 *                                 value: 2
 *                             },
 *                             {
 *                                 text: 'Anti-Vision',
 *                                 value: 1
 *                             }
 *                         ]
 *                     },
 *                     {
 *                         text: 'Ghost Rider',
 *                         value: 3,
 *                         children: [{
 *                             text: 'Mephisto',
 *                             value: 1
 *                         }]
 *                     },
 *                     {
 *                         text: 'Loki',
 *                         value: 2,
 *                         children: [{
 *                             text: 'Captain America',
 *                             value: 3
 *                         },
 *                             {
 *                                 text: 'Deadpool',
 *                                 value: 4
 *                             },
 *                             {
 *                                 text: 'Odin',
 *                                 value: 5
 *                             },
 *                             {
 *                                 text: 'Scarlet Witch',
 *                                 value: 2
 *                             },
 *                             {
 *                                 text: 'Silver Surfer',
 *                                 value: 1
 *                             }
 *                         ]
 *                     },
 *                     {
 *                         text: 'Daredevil',
 *                         value: 1,
 *                         children: [{
 *                             text: 'Purple Man',
 *                             value: 4
 *                         },
 *                             {
 *                                 text: 'Kingpin',
 *                                 value: 3
 *                             },
 *                             {
 *                                 text: 'Namor',
 *                                 value: 2
 *                             },
 *                             {
 *                                 text: 'Sabretooth',
 *                                 value: 1
 *                             }
 *                         ]
 *                     }
 *                 ]
 *             });
 * 
 *         render() {
 *             return (
 *                 <Container layout="fit">
 *                     <D3_TreeMap
 *                         store={this.store}
 *                         tooltip={{
 *                             renderer: function(component, tooltip, node) {
 *                                 tooltip.setHtml(node.data.get('text'));
 *                             }
 *                         }}
 *                     />
 *                 </Container>
 *             )
 *         }
 *     }
 * 
 */
declare class D3_TreeMap extends React.Component<D3_TreeMapProps, any> { }
export interface D3_TreeMapProps extends FlexibleProps {

	/**
	 * An object containing ARIA attributes to be set
	 * on this Component's ARIA element. Use this to set the attributes that cannot be
	 * determined by the Component's state, such as `aria-live`, `aria-flowto`, etc.
	 * 
	 * **Note** that this config is only meaningful at the Component rendering time,
	 * and setting it after that will do nothing.
	 * 
	 */
	ariaAttributes?: any

	/**
	 * DOM selector for a child element that is to be used
	 * as description for this Component, set in `aria-describedby` attribute.
	 * The selector works the same way as ariaLabelledBy.
	 * 
	 */
	ariaDescribedBy?: string

	/**
	 * ARIA label for this Component. It is best to use
	 * ariaLabelledBy option instead, because screen readers prefer
	 * `aria-labelledby` attribute to `aria-label`. ariaLabel and
	 * ariaLabelledBy config options are mutually exclusive.
	 * 
	 */
	ariaLabel?: string

	/**
	 * DOM selector for a child element that is to be used
	 * as label for this Component, set in `aria-labelledby` attribute.
	 * If the selector is by `#id`, the label element can be any existing element,
	 * not necessarily a child of the main Component element.
	 * 
	 * ariaLabelledBy and ariaLabel config options are
	 * mutually exclusive, and `ariaLabelledBy` has the higher precedence.
	 * 
	 */
	ariaLabelledBy?: string

	/**
	 * If `true`, then, when showBy or alignTo fallback on
	 * constraint violation only takes place along the major align axis.
	 * 
	 * That is, if alignment `"l-r"` is being used, and `axisLock: true` is used, then if constraints
	 * fail, only fallback to `"r-l"` is considered.
	 * 
	 */
	axisLock?: boolean

	/**
	 * 
	 * Enables or disables bordering on this component.
	 * The following values are accepted:
	 * 
	 * - `null` or `true (default): Do nothing and allow the border to be specified by the theme.
	 * - `false`: suppress the default border provided by the theme.
	 * 
	 * Please note that enabling bordering via this config will not add a `border-color`
	 * or `border-style` CSS property to the component; you provide the `border-color`
	 * and `border-style` via CSS rule or style configuration
	 * (if not already provide by the theme).
	 * 
	 */
	border?: boolean

	/**
	 * The absolute bottom position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	bottom?: number | string

	/**
	 * The text to show when the layout is in progress.
	 * 
	 */
	busyLayoutText?: string

	/**
	 * Configure this as `true` to have this Component centered within its Container.
	 * Setting this value to `true` will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	centered?: boolean

	/**
	 * If the scene elements that go outside the scene and into the padding area
	 * should be clipped.
	 * Note: stock D3 components are not designed to work with this config set to `true`.
	 * 
	 */
	clipScene?: boolean

	/**
	 * The CSS class to add to this widget's element, in
	 * addition to the baseCls. In many cases, this property will be specified
	 * by the derived widget class. See userCls for adding additional CSS
	 * classes to widget instances (such as items in a Ext.Container).
	 * 
	 */
	cls?: string | string[]

	/**
	 * A Ext.d3.axis.Color config or an instance.
	 * By default (if no 'colorAxis' config is given) all nodes
	 * are assigned a unique color from the `d3.scale.category20c`
	 * scale (until the colors run out, then we start to reuse them)
	 * based on the value of the `name` field.
	 * 
	 */
	colorAxis?: any

	/**
	 * The CSS class used by a subclass of the D3 Component.
	 * Normally, the lower-cased name of a subclass.
	 * 
	 */
	componentCls?: string

	/**
	 * The configured element will automatically be
	 * added as the content of this component. When you pass a string, we expect it to be an element id.
	 * If the content element is hidden, we will automatically show it.
	 * 
	 */
	contentEl?: any | HTMLElement | string

	/**
	 * The initial set of data to apply to the `tpl` to
	 * update the content area of the Component.
	 * 
	 */
	data?: any

	/**
	 * Whether or not this component is disabled
	 * 
	 */
	disabled?: boolean

	/**
	 * The dock position of this component in its container. Can be `left`, `top`, `right` or `bottom`.
	 * 
	 * __Notes__
	 * 
	 * You must use a HTML5 doctype for docked `bottom` to work. To do this, simply add the following code to the HTML file:
	 * 
	 *     <!doctype html>
	 * 
	 * So your index.html file should look a little like this:
	 * 
	 *     <!doctype html>
	 *     <html>
	 *         <head>
	 *             <title>MY application title</title>
	 *             ...
	 * 
	 */
	docked?: string

	/**
	 * Configuration options to make this Component draggable
	 * 
	 */
	draggable?: any

	/**
	 * The expand event(s) to listen for on each node.
	 * The node in question will be expanded, if collapsed,
	 * or collapsed, if expanded.
	 * `false` can be used to prevent listening for the default event.
	 * 
	 */
	expandEventName?: string | string[] | any

	/**
	 * CSS class that will be added to focused
	 * component's focusClsEl, and removed when component blurs.
	 * 
	 */
	focusCls?: string

	/**
	 * Force the component to take up 100% width and height available, by adding it
	 * to Ext.Viewport.
	 * 
	 */
	fullscreen?: boolean

	/**
	 * The height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	height?: number | string

	/**
	 * Whether or not this Component is hidden (its CSS `display` property is set to `none`).
	 * 
	 * Defaults to `true` for floated Components.
	 * 
	 */
	hidden?: boolean

	/**
	 * Animation effect to apply when the Component is being hidden.  Typically you want to use an
	 * outbound animation type such as 'fadeOut' or 'slideOut'. For more animations, check the Ext.fx.Animation#type config.
	 * 
	 */
	hideAnimation?: string | any

	/**
	 * When using a cfg!modal Component, setting this to `true`
	 * will hide the modal mask and the Container when the mask is tapped on.
	 * 
	 */
	hideOnMaskTap?: boolean

	/**
	 * The class name added to all hierarchy components (subclasses).
	 * See also componentCls.
	 * 
	 */
	hierarchyCls?: string

	/**
	 * Optional HTML content to render inside this Component, or a reference
	 * to an existing element on the page.
	 * 
	 */
	html?: string | any | HTMLElement

	/**
	 * The list of interaction configs for this D3 component.
	 * D3 package interactions are very similar to native D3 behaviors.
	 * However, D3 behaviors, as well as event system, is incompatible
	 * with ExtJS event system. D3 package interactions may also support
	 * certain features that D3 behaviors lack, like like kinetic scrolling,
	 * elastic borders and scroll indicators (see the Ext.d3.interaction.PanZoom
	 * interaction for more information).
	 * 
	 */
	interactions?: any[]

	/**
	 * An object containing handlers for keyboard events. The property names of this
	 * object are the key name and any modifiers. The values of the properties are the
	 * descriptors of how to handle each event.
	 * 
	 * The handler descriptor can be simply the handler function (either the
	 * literal function or the method name), or it can be an object with these
	 * properties:
	 * 
	 *  - `handler`: The function or its name to call to handle the event.
	 *  - `scope`: The this pointer context (can be "this" or "controller").
	 *  - `event`: An optional override of the key event to which to listen.
	 * 
	 * **Important:** Calls to `setKeyMap` do not replace the entire `keyMap` but
	 * instead update the provided mappings. That is, unless `null` is passed as the
	 * value of the `keyMap` which will clear the `keyMap` of all entries.
	 * 
	 */
	keyMap?: any

	/**
	 * Enables or disables processing keys in the `keyMap`. This value starts as
	 * `null` and if it is `null` when `initKeyMap` is called, it will automatically
	 * be set to `true`. Since `initKeyMap` is called by `Ext.Component` at the
	 * proper time, this is not something application code normally handles.
	 * 
	 */
	keyMapEnabled?: boolean

	/**
	 * Leaf tile options.
	 * 
	 */
	leafTile?: any

	/**
	 * The absolute left position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	left?: number | string

	/**
	 * The [key](https://github.com/d3/d3-selection/#selection_data) function for links.
	 * Returns the 'id' of the link's target Ext.data.TreeModel by default.
	 * 
	 */
	linkKey?: Function

	/**
	 * 
	 * A config object containing one or more event handlers to be added to this object during initialization. This
	 * should be a valid listeners config object as specified in the
	 * addListener example for attaching
	 * multiple handlers at once.
	 * 
	 * **DOM events from Ext JS Ext.Component**
	 * 
	 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
	 * only done when extra value can be added. For example the DataView's **`itemclick`** event passing the node clicked on. To access DOM events directly from a
	 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
	 * DOM listener to:
	 * 
	 *     new Ext.panel.Panel({
	 *         width: 400,
	 *         height: 200,
	 *         dockedItems: [{
	 *             xtype: 'toolbar'
	 *         }],
	 *         listeners: {
	 *             click: {
	 *                 element: 'el', //bind to the underlying el property on the panel
	 *                 fn: function(){ console.log('click el'); }
	 *             },
	 *             dblclick: {
	 *                 element: 'body', //bind to the underlying body property on the panel
	 *                 fn: function(){ console.log('dblclick body'); }
	 *             }
	 *         }
	 *     });
	 * 
	 */
	listeners?: any

	/**
	 * The margin to use on this Component. Can be specified as a number (in which case
	 * all edges get the same margin) or a CSS string like '5 10 10 10'
	 * 
	 */
	margin?: number | string

	/**
	 * The maximum height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * Note that this config will not apply if the Component is 'positioned' (absolutely positioned or centered)
	 * 
	 */
	maxHeight?: number | string

	/**
	 * The maximum width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * Note that this config will not apply if the Component is 'positioned' (absolutely positioned or centered)
	 * 
	 */
	maxWidth?: number | string

	/**
	 * The minimum height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	minHeight?: number | string

	/**
	 * The minimum width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	minWidth?: number | string

	/**
	 * `true` to make this Component modal. This will create a mask underneath the Component
	 * that covers its parent and does not allow the user to interact with any other Components until this
	 * Component is dismissed.
	 * 
	 */
	modal?: boolean

	/**
	 * Name for the widget to be used with Ext.Container#lookupName et al.
	 * 
	 */
	name?: string

	/**
	 * [Children](https://github.com/d3/d3-hierarchy/#hierarchy) accessor function.
	 * Defaults to returning node's nodes,
	 * if the node is expanded or null otherwise
	 * (meaning children of collapsed nodes are not rendered).
	 * 
	 */
	nodeChildren?: Function

	/**
	 * A function that updates class attributes of a given selection.
	 * By default adds the following classes to node elements:
	 * - `x-d3-parent` - if a node is a parent node;
	 * - `x-d3-leaf` - if a node is a leaf node;
	 * - `x-d3-expanded` - if a node is expanded;
	 * - `x-d3-root` - if a node is the root node (represents the root of the store);
	 * - `x-d3-layout-root` - if a node is the root node of the current layout.
	 * 
	 */
	nodeClass?: Function

	/**
	 * The [key](https://github.com/d3/d3-selection/#selection_data) function for nodes.
	 * Returns the 'id' of the node's Ext.data.TreeModel by default.
	 * 
	 */
	nodeKey?: Function

	/**
	 * A function that returns a text string, given a component and  node (d3.hierarchy) instance.
	 * Alternatively, can be a field name or an array of field names used to fetch the text.
	 * If array of field names is given, the first non-empty string will be used.
	 * A node holds a reference to the Ext.data.TreeModel instance
	 * in its `data` field.
	 * For example, to return the value of the record's field `name` as node's text
	 * the following function can be used:
	 * 
	 *     nodeText: function (component, node) {
	 *         var record = node.data,
	 *             text = record.get('name');
	 * 
	 *         return text;
	 *     }
	 * 
	 * Or simply:
	 * 
	 *     nodeText: 'name'
	 * 
	 * To return the value of the `title` field, if the `name` field is empty:
	 * 
	 *     nodeText: ['name', 'title']
	 * 
	 */
	nodeText?: Function | string | string[]

	/**
	 * [The function](https://github.com/d3/d3-hierarchy#node_sum) that receives
	 * the node's data (tree store record) and returns the numeric value of the node.
	 * This config can also be a field name or a number, in which case it will be
	 * converted to a function that returns the value of the specified field,
	 * or a function that returns the given number for all nodes.
	 * Note: nodeChildren does not have effect on this config, even
	 * though only expanded nodes will render by default, the `nodeValue`
	 * function will be called for all nodes.
	 * 
	 */
	nodeValue?: Function | string | number

	/**
	 * If `true` the nodeValue function will not be called for parent nodes,
	 * instead they'll get a value of zero.
	 * The nodeChildren function is used to determine if a node is a parent.
	 * 
	 */
	noParentValue?: boolean

	/**
	 * The padding of the scene.
	 * See Ext.util.Format#parseBox for syntax details,
	 * if using a string for this config.
	 * 
	 */
	padding?: any | string | number

	/**
	 * 
	 * Parent tile options.
	 * 
	 */
	parentTile?: any

	/**
	 * An object or array of objects that will provide custom functionality for this
	 * component. If a string is provided or a string is one of the elements of the
	 * array, that string is treated as the `type` alias. For example, "listpaging"
	 * is the type alias for `Ext.plugin.ListPaging`. The full alias includes the
	 * "plugin." prefix (i.e., 'plugin.listpaging').
	 * 
	 * Plugins should derive from `Ext.plugin.Abstract` but this is not required. The
	 * only requirement for a valid plugin is that it contain an `init()` method that
	 * accepts a reference to the owning component.
	 * 
	 * When a component is created, if any plugins are available, the component will
	 * call the `init` method on each plugin,
	 * passing a reference to itself. Each plugin can then call methods or respond to
	 * events on the component as needed to provide its functionality.
	 * 
	 * ## Example code
	 * 
	 * A plugin by alias:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: 'listpaging'
	 *      });
	 * 
	 * Multiple plugins by alias:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: ['listpaging', 'pullrefresh']
	 *      });
	 * 
	 * Single plugin by class name with config options:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: {
	 *              type: 'listpaging',
	 *              autoPaging: true
	 *          }
	 *      });
	 * 
	 * Multiple plugins by type and class name with config options:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: [{
	 *              xclass: 'Ext.plugin.PullRefresh',
	 *              pullRefreshText: 'Pull to refresh...'
	 *          }, {
	 *              type: 'listpaging',
	 *              autoPaging: true
	 *          }]
	 *      });
	 * 
	 */
	plugins?: any | string | any[] | string[]

	/**
	 * A model instance which updates the Component's html based on it's tpl. Similar to the data
	 * configuration, but tied to to a record to make allow dynamic updates.  This must be a model
	 * instance and not a configuration of one.
	 * 
	 */
	record?: any

	/**
	 * Optional element to render this Component to.
	 * Not required if this component is an item of a Container of a Container.
	 * 
	 */
	renderTo?: any

	/**
	 * The absolute right position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	right?: number | string

	/**
	 * False to hide the root node.
	 * 
	 */
	rootVisible?: boolean

	/**
	 * If `true` the bigger tiles will have (more or less) proportionally bigger labels.
	 * 
	 */
	scaleLabels?: boolean

	/**
	 * Configuration options to make this Component scrollable. Acceptable values are:
	 * 
	 * - `true` to enable auto scrolling.
	 * - `false` (or `null`) to disable scrolling - this is the default.
	 * - `x` or `horizontal` to enable horizontal scrolling only
	 * - `y` or `vertical` to enable vertical scrolling only
	 * 
	 * Also accepts a configuration object for a `Ext.scroll.Scroller` if
	 * if advanced configuration is needed.
	 * 
	 * The getter for this config returns the Ext.scroll.Scroller
	 * instance.  You can use the Scroller API to read or manipulate the scroll position:
	 * 
	 *     // scrolls the component to 5 on the x axis and 10 on the y axis
	 *     component.getScrollable().scrollTo(5, 10);
	 * 
	 */
	scrollable?: boolean | string | any

	/**
	 * The select event(s) to listen for on each node.
	 * The node in question will be selected,
	 * selection will be removed from the previously selected node.
	 * The select event won't be handled when Ctrl/Cmd is pressed.
	 * For example, this allows to expand a node by double-clicking
	 * without selecting it.
	 * `false` can be used to prevent listening for the default event.
	 * 
	 */
	selectEventName?: string | string[] | any

	/**
	 * The selected record. Typically used with binding.
	 * 
	 */
	selection?: any

	/**
	 * Animation effect to apply when the Component is being shown.  Typically you want to use an
	 * inbound animation type such as 'fadeIn' or 'slideIn'. For more animations, check the Ext.fx.Animation#type config.
	 * 
	 */
	showAnimation?: string | any

	/**
	 * Whether or not the component got its first size.
	 * Can be used in the `sceneresize` event handler to do user-defined setup on first
	 * resize, for example:
	 * 
	 *     listeners: {
	 *         sceneresize: function (component, scene, rect) {
	 *             if (!component.size) {
	 *                 // set things up
	 *             } else {
	 *                 // handle resize
	 *             }
	 *         }
	 *     }
	 * 
	 */
	size?: any

	/**
	 * The store with data to render.
	 * 
	 */
	store?: any

	/**
	 * Additional CSS styles that will be rendered into an inline style attribute when
	 * the widget is rendered.
	 * 
	 * You can pass either a string syntax:
	 * 
	 *     style: 'background:red'
	 * 
	 * Or by using an object:
	 * 
	 *     style: {
	 *         background: 'red'
	 *     }
	 * 
	 * When using the object syntax, you can define CSS Properties by using a string:
	 * 
	 *     style: {
	 *         'border-left': '1px solid red'
	 *     }
	 * 
	 * Although the object syntax is much easier to read, we suggest you to use the
	 * string syntax for better performance.
	 * 
	 */
	style?: string | any

	/**
	 * DOM tabIndex attribute for this component's focusEl.
	 * 
	 */
	tabIndex?: number

	/**
	 * The [tiling method](https://github.com/d3/d3-hierarchy#treemap_tile) to use
	 * with the `treemap` layout. For example:
	 * 
	 *     tiling: 'd3.treemapBinary'
	 * 
	 */
	tiling?: Function

	/**
	 * The Ext.tip.ToolTip for this component.
	 * 
	 *     <Button text="Basic Tip">
	 *         <ToolTip>A simple tooltip</ToolTip>
	 *     </Button>
	 * 
	 */
	tooltip?: any

	/**
	 * The absolute top position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	top?: number | string

	/**
	 * 
	 * Emulates the behavior of the CSS [touch-action](https://www.w3.org/TR/pointerevents/#the-touch-action-css-property)
	 * property in a cross-browser compatible manner.
	 * 
	 * Keys in this object are touch action names, and values are `false` to disable
	 * a touch action or `true` to enable it.  Accepted keys are:
	 * 
	 * - `panX`
	 * - `panY`
	 * - `pinchZoom`
	 * - `doubleTapZoom`
	 * 
	 * All touch actions are enabled (`true`) by default, so it is usually only necessary
	 * to specify which touch actions to disable.  For example, the following disables
	 * only horizontal scrolling and pinch-to-zoom on the component's main element:
	 * 
	 *     touchAction: {
	 *         panX: false,
	 *         pinchZoom: false
	 *     }
	 * 
	 * Touch actions can be specified on reference elements using the reference element
	 * name, for example:
	 * 
	 *     // disables horizontal scrolling on the main element, and double-tap-zoom
	 *     // on the child element named "body"
	 *     touchAction: {
	 *         panY: false
	 *         body: {
	 *             doubleTapZoom: false
	 *         }
	 *     }
	 * 
	 * The primary motivation for setting the touch-action of an element is to prevent
	 * the browser's default handling of a gesture such as pinch-to-zoom, or
	 * drag-to-scroll, so that the application can implement its own handling of that
	 * gesture on the element.  Suppose, for example, a component has a custom drag
	 * handler on its element and wishes to prevent horizontal scrolling of its container
	 * while it is being dragged:
	 * 
	 *     Ext.create('Ext.Widget', {
	 *         touchAction: {
	 *             panX: false
	 *         },
	 *         listeners: {
	 *             drag: function(e) {
	 *                 // implement drag logic
	 *             }
	 *         }
	 *     });
	 * 
	 */
	touchAction?: any

	/**
	 * 
	 * A string, array of strings, or a function that returns JSX.
	 * 
	 *    tpl = data => <div>{data.first_name} {data.last_name}</div>
	 * 
	 * __Note__
	 * The data configuration _must_ be set for any content to be shown in the component when using this configuration.
	 * 
	 */
	tpl?: Function | string | string[]

	/**
	 * The Ext.(X)Template method to use when updating the content area of the Component.
	 * 
	 * Valid modes are:
	 * 
	 * - append
	 * - insertAfter
	 * - insertBefore
	 * - insertFirst
	 * - overwrite
	 * 
	 */
	tplWriteMode?: string

	/**
	 * A map of transition configs. For example:
	 * 
	 *     transitions: {
	 *         select: {
	 *             duration: 500,
	 *             ease: 'cubicInOut'
	 *         },
	 *         zoom: {
	 *             name: 'zoom',
	 *             duration: 1000
	 *         },
	 *         ...
	 *     }
	 * 
	 * A class would define the defaults for its transitions, and a user only needs
	 * to set the `transitions` config of an instance to disable a transition, e.g.:
	 * 
	 *     transitions: {
	 *         // transitions are enabled by default, `true` should never be used here
	 *         select: false
	 *     }
	 * 
	 * or alter its config:
	 * 
	 *     transitions: {
	 *         select: {
	 *             // the `duration` stays the same,
	 *             // only the easing function is altered
	 *             ease: 'bounceOut'
	 *         }
	 *     }
	 * 
	 * The transitions defined this way are merely configs. To create an actual transition
	 * from one of these configs, use the createTransition method. For example:
	 * 
	 *     this.createTransition('select')
	 * 
	 * A transition object can optionally specify a name, if it's different from
	 * the key in the `transitions` config. For example:
	 * 
	 *     transitions: {
	 *         layout: {
	 *             name: 'foo',
	 *             duration: 500
	 *         }
	 *     }
	 * 
	 * Otherwise the name will be set automatically, for example:
	 * 
	 *     transition.name = this.getId() + '-' + key
	 * 
	 * Transition names (whether explicitly given or not) are prefixed by component ID
	 * to prevent transitions with the same name but on a different component from
	 * cancelling each other out.
	 * 
	 * However, transitions with the same name on the same component will still cancel
	 * each other out, if created via createTransition on the same selection
	 * or with no selection provided.
	 * 
	 * `duration`, `ease` and `name` properties of transition objects in this config
	 * are reserved, and will be used to configure a `d3.transition` instance.
	 * However, transition objects may also have other properties that are related to
	 * this transition. For example:
	 * 
	 *     transitions: {
	 *         select: {
	 *             duration: 500,
	 *             ease: 'cubicInOut',
	 *             targetScale: 1.1
	 *         }
	 *     }
	 * 
	 * The `targetScale` property here won't be consumed by a `d3.transition` instance;
	 * instead a component can make use of it in whichever way it sees fit to animate
	 * the selected element.
	 * 
	 */
	transitions?: any

	/**
	 * The ui or uis to be used on this Component
	 * 
	 * When a ui is configured, CSS class names are added to the element, created
	 * by appending the ui name(s) to each classCls and/or baseCls.
	 * 
	 */
	ui?: string | string[]

	/**
	 * One or more CSS classes to add to the component's primary element. This config
	 * is intended solely for use by the component instantiator (the "user"), not by
	 * derived classes.
	 * 
	 * For example:
	 * 
	 *      items: [{
	 *          xtype: 'button',
	 *          userCls: 'my-button'
	 *      ...
	 *      }]
	 * 
	 */
	userCls?: string | string[]

	/**
	 * This value controls this item's order in a Ext.Container#cfg!weighted
	 * Ext.Container (see cfg!parent).
	 * 
	 * Lower values gravitate towards the start of the container - the top in vertical layouts, the
	 * locale start side in horizontal layouts.
	 * 
	 */
	weight?: number

	/**
	 * The width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	width?: number | string

	/**
	 * The z-index to give this Component when it is rendered.
	 * 
	 * Not valid for cfg-floated Components. The Z ordering of cfg-floated
	 * Components is managed by ordering of the DOM elements.
	 * 
	 */
	zIndex?: number

	/**
	 * Fires after a Component had been added to a Container.
	 * 
	 */
	onAdded?: (me: any, container: any, index: number) => void

	/**
	 * This event fires when `cfg!bottom` changes.
	 */
	onBeforeBottomChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!centered` changes.
	 */
	onBeforeCenteredChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!disabled` changes.
	 */
	onBeforeDisabledChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!docked` changes.
	 */
	onBeforeDockedChange?: (sender: any, value: string, oldValue: string) => void

	/**
	 * This event fires when `cfg!height` changes.
	 */
	onBeforeHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!hidden` changes.
	 */
	onBeforeHiddenChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires before the Component is hidden. Hide may be vetoed by returning `false` from a handler.
	 * 
	 */
	onBeforeHide?: (me: any) => void

	/**
	 * This event fires when `cfg!left` changes.
	 */
	onBeforeLeftChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxHeight` changes.
	 */
	onBeforeMaxHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxWidth` changes.
	 */
	onBeforeMaxWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minHeight` changes.
	 */
	onBeforeMinHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minWidth` changes.
	 */
	onBeforeMinWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!right` changes.
	 */
	onBeforeRightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!scrollable` changes.
	 */
	onBeforeScrollableChange?: (sender: any, value: boolean | string | any, oldValue: boolean | string | any) => void

	/**
	 * Fires before the Component is shown. Show may be vetoed by returning `false` from a handler.
	 * 
	 */
	onBeforeShow?: (me: any) => void

	/**
	 * This event fires when `cfg!top` changes.
	 */
	onBeforeTopChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!width` changes.
	 */
	onBeforeWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires when this Component's focusEl loses focus.
	 * 
	 */
	onBlur?: (me: any, event: any) => void

	/**
	 * This event fires when `cfg!bottom` changes.
	 */
	onBottomChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!centered` changes.
	 */
	onCenteredChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires when the component is destroyed
	 * 
	 */
	onDestroy?: () => void

	/**
	 * This event fires when `cfg!disabled` changes.
	 */
	onDisabledChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!docked` changes.
	 */
	onDockedChange?: (sender: any, value: string, oldValue: string) => void

	/**
	 * Fires when the component is no longer displayed in the DOM.  Listening to this event will
	 * degrade performance not recommend for general use.
	 * 
	 */
	onErased?: (me: any) => void

	/**
	 * Fires when this Component's focusEl receives focus.
	 * 
	 */
	onFocus?: (me: any, event: any) => void

	/**
	 * Fires when focus enters this Component's hierarchy.
	 * 
	 */
	onFocusEnter?: (me: any, event: any) => void

	/**
	 * Fires when focus leaves this Component's hierarchy.
	 * 
	 */
	onFocusLeave?: (me: any, event: any) => void

	/**
	 * Fires whenever a Component with the fullscreen config is instantiated
	 * 
	 */
	onFullscreen?: (me: any) => void

	/**
	 * This event fires when `cfg!height` changes.
	 */
	onHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!hidden` changes.
	 */
	onHiddenChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires whenever the Component is hidden
	 * 
	 */
	onHide?: (me: any) => void

	/**
	 * Fires when the component has been initialized
	 * 
	 */
	onInitialize?: (me: any) => void

	/**
	 * This event fires when `cfg!left` changes.
	 */
	onLeftChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxHeight` changes.
	 */
	onMaxHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxWidth` changes.
	 */
	onMaxWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minHeight` changes.
	 */
	onMinHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minWidth` changes.
	 */
	onMinWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires when a component si moved within its Container.
	 * 
	 */
	onMoved?: (me: any, container: any, toIndex: number, fromIndex: number) => void

	/**
	 * Fires whenever this Element actually becomes visible (painted) on the screen. This is useful when you need to
	 * perform 'read' operations on the DOM element, i.e: calculating natural sizes and positioning.
	 * 
	 * __Note:__ This event is not available to be used with event delegation. Instead `painted` only fires if you explicitly
	 * add at least one listener to it, for performance reasons.
	 * 
	 */
	onPainted?: (element: any) => void

	/**
	 * Fires whenever there is a change in the positioned status of a component
	 * 
	 */
	onPositionedChange?: (me: any, positioned: boolean) => void

	/**
	 * Fires when a component is removed from a Container
	 * 
	 */
	onRemoved?: (me: any, container: any, index: number) => void

	/**
	 * Fires *asynchronously* after a browser layout caused by a component resize. This may be triggered for any or
	 * several of the following reasons:
	 *    - Programmatic changes to cfg-width or cfg-height configs.
	 *    - Setting the cfg-flex config when the owning layout is Ext.layout.Box.
	 *    - Setting cfg-minHeight, cfg-maxHeight, cfg-minWidth or cfg-maxWidth.
	 *    - Changing device orientation.
	 *    - Changing the browser viewport size.
	 *    - Any resize caused by browser layout recalculation which may be caused by content size changes
	 *      or application of default browser layout rules.
	 * 
	 */
	onResize?: (component: any, width: string | number, height: string | number, oldWidth: string | number, oldHeight: string | number) => void

	/**
	 * This event fires when `cfg!right` changes.
	 */
	onRightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires after scene size has changed.
	 * Notes: the scene is a 'g' element, so it cannot actually have a size.
	 * The size reported is the size the drawing is supposed to fit in.
	 * 
	 */
	onSceneResize?: (component: any, scene: any, size: any) => void

	/**
	 * Fires once after the scene has been created.
	 * Note that at this time the component doesn't have a size yet.
	 * 
	 */
	onSceneSetup?: (component: any, scene: any) => void

	/**
	 * This event fires when `cfg!scrollable` changes.
	 */
	onScrollableChange?: (sender: any, value: boolean | string | any, oldValue: boolean | string | any) => void

	/**
	 * Fires whenever the Component is shown
	 * 
	 */
	onShow?: (me: any) => void

	/**
	 * This event fires when `cfg!top` changes.
	 */
	onTopChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!width` changes.
	 */
	onWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void
}

/**
 * 
 * The base class of every SVG D3 Component that can also be used standalone.
 * 
 */
declare class D3_SVG extends React.Component<D3_SVGProps, any> { }
export interface D3_SVGProps extends FlexibleProps {

	/**
	 * An object containing ARIA attributes to be set
	 * on this Component's ARIA element. Use this to set the attributes that cannot be
	 * determined by the Component's state, such as `aria-live`, `aria-flowto`, etc.
	 * 
	 * **Note** that this config is only meaningful at the Component rendering time,
	 * and setting it after that will do nothing.
	 * 
	 */
	ariaAttributes?: any

	/**
	 * DOM selector for a child element that is to be used
	 * as description for this Component, set in `aria-describedby` attribute.
	 * The selector works the same way as ariaLabelledBy.
	 * 
	 */
	ariaDescribedBy?: string

	/**
	 * ARIA label for this Component. It is best to use
	 * ariaLabelledBy option instead, because screen readers prefer
	 * `aria-labelledby` attribute to `aria-label`. ariaLabel and
	 * ariaLabelledBy config options are mutually exclusive.
	 * 
	 */
	ariaLabel?: string

	/**
	 * DOM selector for a child element that is to be used
	 * as label for this Component, set in `aria-labelledby` attribute.
	 * If the selector is by `#id`, the label element can be any existing element,
	 * not necessarily a child of the main Component element.
	 * 
	 * ariaLabelledBy and ariaLabel config options are
	 * mutually exclusive, and `ariaLabelledBy` has the higher precedence.
	 * 
	 */
	ariaLabelledBy?: string

	/**
	 * If `true`, then, when showBy or alignTo fallback on
	 * constraint violation only takes place along the major align axis.
	 * 
	 * That is, if alignment `"l-r"` is being used, and `axisLock: true` is used, then if constraints
	 * fail, only fallback to `"r-l"` is considered.
	 * 
	 */
	axisLock?: boolean

	/**
	 * 
	 * Enables or disables bordering on this component.
	 * The following values are accepted:
	 * 
	 * - `null` or `true (default): Do nothing and allow the border to be specified by the theme.
	 * - `false`: suppress the default border provided by the theme.
	 * 
	 * Please note that enabling bordering via this config will not add a `border-color`
	 * or `border-style` CSS property to the component; you provide the `border-color`
	 * and `border-style` via CSS rule or style configuration
	 * (if not already provide by the theme).
	 * 
	 */
	border?: boolean

	/**
	 * The absolute bottom position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	bottom?: number | string

	/**
	 * Configure this as `true` to have this Component centered within its Container.
	 * Setting this value to `true` will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	centered?: boolean

	/**
	 * If the scene elements that go outside the scene and into the padding area
	 * should be clipped.
	 * Note: stock D3 components are not designed to work with this config set to `true`.
	 * 
	 */
	clipScene?: boolean

	/**
	 * The CSS class to add to this widget's element, in
	 * addition to the baseCls. In many cases, this property will be specified
	 * by the derived widget class. See userCls for adding additional CSS
	 * classes to widget instances (such as items in a Ext.Container).
	 * 
	 */
	cls?: string | string[]

	/**
	 * The CSS class used by a subclass of the D3 Component.
	 * Normally, the lower-cased name of a subclass.
	 * 
	 */
	componentCls?: string

	/**
	 * The configured element will automatically be
	 * added as the content of this component. When you pass a string, we expect it to be an element id.
	 * If the content element is hidden, we will automatically show it.
	 * 
	 */
	contentEl?: any | HTMLElement | string

	/**
	 * The initial set of data to apply to the `tpl` to
	 * update the content area of the Component.
	 * 
	 */
	data?: any

	/**
	 * Whether or not this component is disabled
	 * 
	 */
	disabled?: boolean

	/**
	 * The dock position of this component in its container. Can be `left`, `top`, `right` or `bottom`.
	 * 
	 * __Notes__
	 * 
	 * You must use a HTML5 doctype for docked `bottom` to work. To do this, simply add the following code to the HTML file:
	 * 
	 *     <!doctype html>
	 * 
	 * So your index.html file should look a little like this:
	 * 
	 *     <!doctype html>
	 *     <html>
	 *         <head>
	 *             <title>MY application title</title>
	 *             ...
	 * 
	 */
	docked?: string

	/**
	 * Configuration options to make this Component draggable
	 * 
	 */
	draggable?: any

	/**
	 * CSS class that will be added to focused
	 * component's focusClsEl, and removed when component blurs.
	 * 
	 */
	focusCls?: string

	/**
	 * Force the component to take up 100% width and height available, by adding it
	 * to Ext.Viewport.
	 * 
	 */
	fullscreen?: boolean

	/**
	 * The height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	height?: number | string

	/**
	 * Whether or not this Component is hidden (its CSS `display` property is set to `none`).
	 * 
	 * Defaults to `true` for floated Components.
	 * 
	 */
	hidden?: boolean

	/**
	 * Animation effect to apply when the Component is being hidden.  Typically you want to use an
	 * outbound animation type such as 'fadeOut' or 'slideOut'. For more animations, check the Ext.fx.Animation#type config.
	 * 
	 */
	hideAnimation?: string | any

	/**
	 * When using a cfg!modal Component, setting this to `true`
	 * will hide the modal mask and the Container when the mask is tapped on.
	 * 
	 */
	hideOnMaskTap?: boolean

	/**
	 * Optional HTML content to render inside this Component, or a reference
	 * to an existing element on the page.
	 * 
	 */
	html?: string | any | HTMLElement

	/**
	 * The list of interaction configs for this D3 component.
	 * D3 package interactions are very similar to native D3 behaviors.
	 * However, D3 behaviors, as well as event system, is incompatible
	 * with ExtJS event system. D3 package interactions may also support
	 * certain features that D3 behaviors lack, like like kinetic scrolling,
	 * elastic borders and scroll indicators (see the Ext.d3.interaction.PanZoom
	 * interaction for more information).
	 * 
	 */
	interactions?: any[]

	/**
	 * An object containing handlers for keyboard events. The property names of this
	 * object are the key name and any modifiers. The values of the properties are the
	 * descriptors of how to handle each event.
	 * 
	 * The handler descriptor can be simply the handler function (either the
	 * literal function or the method name), or it can be an object with these
	 * properties:
	 * 
	 *  - `handler`: The function or its name to call to handle the event.
	 *  - `scope`: The this pointer context (can be "this" or "controller").
	 *  - `event`: An optional override of the key event to which to listen.
	 * 
	 * **Important:** Calls to `setKeyMap` do not replace the entire `keyMap` but
	 * instead update the provided mappings. That is, unless `null` is passed as the
	 * value of the `keyMap` which will clear the `keyMap` of all entries.
	 * 
	 */
	keyMap?: any

	/**
	 * Enables or disables processing keys in the `keyMap`. This value starts as
	 * `null` and if it is `null` when `initKeyMap` is called, it will automatically
	 * be set to `true`. Since `initKeyMap` is called by `Ext.Component` at the
	 * proper time, this is not something application code normally handles.
	 * 
	 */
	keyMapEnabled?: boolean

	/**
	 * The absolute left position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	left?: number | string

	/**
	 * 
	 * A config object containing one or more event handlers to be added to this object during initialization. This
	 * should be a valid listeners config object as specified in the
	 * addListener example for attaching
	 * multiple handlers at once.
	 * 
	 * **DOM events from Ext JS Ext.Component**
	 * 
	 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
	 * only done when extra value can be added. For example the DataView's **`itemclick`** event passing the node clicked on. To access DOM events directly from a
	 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
	 * DOM listener to:
	 * 
	 *     new Ext.panel.Panel({
	 *         width: 400,
	 *         height: 200,
	 *         dockedItems: [{
	 *             xtype: 'toolbar'
	 *         }],
	 *         listeners: {
	 *             click: {
	 *                 element: 'el', //bind to the underlying el property on the panel
	 *                 fn: function(){ console.log('click el'); }
	 *             },
	 *             dblclick: {
	 *                 element: 'body', //bind to the underlying body property on the panel
	 *                 fn: function(){ console.log('dblclick body'); }
	 *             }
	 *         }
	 *     });
	 * 
	 */
	listeners?: any

	/**
	 * The margin to use on this Component. Can be specified as a number (in which case
	 * all edges get the same margin) or a CSS string like '5 10 10 10'
	 * 
	 */
	margin?: number | string

	/**
	 * The maximum height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * Note that this config will not apply if the Component is 'positioned' (absolutely positioned or centered)
	 * 
	 */
	maxHeight?: number | string

	/**
	 * The maximum width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * Note that this config will not apply if the Component is 'positioned' (absolutely positioned or centered)
	 * 
	 */
	maxWidth?: number | string

	/**
	 * The minimum height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	minHeight?: number | string

	/**
	 * The minimum width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	minWidth?: number | string

	/**
	 * `true` to make this Component modal. This will create a mask underneath the Component
	 * that covers its parent and does not allow the user to interact with any other Components until this
	 * Component is dismissed.
	 * 
	 */
	modal?: boolean

	/**
	 * Name for the widget to be used with Ext.Container#lookupName et al.
	 * 
	 */
	name?: string

	/**
	 * The padding of the scene.
	 * See Ext.util.Format#parseBox for syntax details,
	 * if using a string for this config.
	 * 
	 */
	padding?: any | string | number

	/**
	 * An object or array of objects that will provide custom functionality for this
	 * component. If a string is provided or a string is one of the elements of the
	 * array, that string is treated as the `type` alias. For example, "listpaging"
	 * is the type alias for `Ext.plugin.ListPaging`. The full alias includes the
	 * "plugin." prefix (i.e., 'plugin.listpaging').
	 * 
	 * Plugins should derive from `Ext.plugin.Abstract` but this is not required. The
	 * only requirement for a valid plugin is that it contain an `init()` method that
	 * accepts a reference to the owning component.
	 * 
	 * When a component is created, if any plugins are available, the component will
	 * call the `init` method on each plugin,
	 * passing a reference to itself. Each plugin can then call methods or respond to
	 * events on the component as needed to provide its functionality.
	 * 
	 * ## Example code
	 * 
	 * A plugin by alias:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: 'listpaging'
	 *      });
	 * 
	 * Multiple plugins by alias:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: ['listpaging', 'pullrefresh']
	 *      });
	 * 
	 * Single plugin by class name with config options:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: {
	 *              type: 'listpaging',
	 *              autoPaging: true
	 *          }
	 *      });
	 * 
	 * Multiple plugins by type and class name with config options:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: [{
	 *              xclass: 'Ext.plugin.PullRefresh',
	 *              pullRefreshText: 'Pull to refresh...'
	 *          }, {
	 *              type: 'listpaging',
	 *              autoPaging: true
	 *          }]
	 *      });
	 * 
	 */
	plugins?: any | string | any[] | string[]

	/**
	 * A model instance which updates the Component's html based on it's tpl. Similar to the data
	 * configuration, but tied to to a record to make allow dynamic updates.  This must be a model
	 * instance and not a configuration of one.
	 * 
	 */
	record?: any

	/**
	 * Optional element to render this Component to.
	 * Not required if this component is an item of a Container of a Container.
	 * 
	 */
	renderTo?: any

	/**
	 * The absolute right position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	right?: number | string

	/**
	 * Configuration options to make this Component scrollable. Acceptable values are:
	 * 
	 * - `true` to enable auto scrolling.
	 * - `false` (or `null`) to disable scrolling - this is the default.
	 * - `x` or `horizontal` to enable horizontal scrolling only
	 * - `y` or `vertical` to enable vertical scrolling only
	 * 
	 * Also accepts a configuration object for a `Ext.scroll.Scroller` if
	 * if advanced configuration is needed.
	 * 
	 * The getter for this config returns the Ext.scroll.Scroller
	 * instance.  You can use the Scroller API to read or manipulate the scroll position:
	 * 
	 *     // scrolls the component to 5 on the x axis and 10 on the y axis
	 *     component.getScrollable().scrollTo(5, 10);
	 * 
	 */
	scrollable?: boolean | string | any

	/**
	 * Animation effect to apply when the Component is being shown.  Typically you want to use an
	 * inbound animation type such as 'fadeIn' or 'slideIn'. For more animations, check the Ext.fx.Animation#type config.
	 * 
	 */
	showAnimation?: string | any

	/**
	 * Whether or not the component got its first size.
	 * Can be used in the `sceneresize` event handler to do user-defined setup on first
	 * resize, for example:
	 * 
	 *     listeners: {
	 *         sceneresize: function (component, scene, rect) {
	 *             if (!component.size) {
	 *                 // set things up
	 *             } else {
	 *                 // handle resize
	 *             }
	 *         }
	 *     }
	 * 
	 */
	size?: any

	/**
	 * The store with data to render.
	 * 
	 */
	store?: any

	/**
	 * Additional CSS styles that will be rendered into an inline style attribute when
	 * the widget is rendered.
	 * 
	 * You can pass either a string syntax:
	 * 
	 *     style: 'background:red'
	 * 
	 * Or by using an object:
	 * 
	 *     style: {
	 *         background: 'red'
	 *     }
	 * 
	 * When using the object syntax, you can define CSS Properties by using a string:
	 * 
	 *     style: {
	 *         'border-left': '1px solid red'
	 *     }
	 * 
	 * Although the object syntax is much easier to read, we suggest you to use the
	 * string syntax for better performance.
	 * 
	 */
	style?: string | any

	/**
	 * DOM tabIndex attribute for this component's focusEl.
	 * 
	 */
	tabIndex?: number

	/**
	 * The Ext.tip.ToolTip for this component.
	 * 
	 *     <Button text="Basic Tip">
	 *         <ToolTip>A simple tooltip</ToolTip>
	 *     </Button>
	 * 
	 */
	tooltip?: any

	/**
	 * The absolute top position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	top?: number | string

	/**
	 * 
	 * Emulates the behavior of the CSS [touch-action](https://www.w3.org/TR/pointerevents/#the-touch-action-css-property)
	 * property in a cross-browser compatible manner.
	 * 
	 * Keys in this object are touch action names, and values are `false` to disable
	 * a touch action or `true` to enable it.  Accepted keys are:
	 * 
	 * - `panX`
	 * - `panY`
	 * - `pinchZoom`
	 * - `doubleTapZoom`
	 * 
	 * All touch actions are enabled (`true`) by default, so it is usually only necessary
	 * to specify which touch actions to disable.  For example, the following disables
	 * only horizontal scrolling and pinch-to-zoom on the component's main element:
	 * 
	 *     touchAction: {
	 *         panX: false,
	 *         pinchZoom: false
	 *     }
	 * 
	 * Touch actions can be specified on reference elements using the reference element
	 * name, for example:
	 * 
	 *     // disables horizontal scrolling on the main element, and double-tap-zoom
	 *     // on the child element named "body"
	 *     touchAction: {
	 *         panY: false
	 *         body: {
	 *             doubleTapZoom: false
	 *         }
	 *     }
	 * 
	 * The primary motivation for setting the touch-action of an element is to prevent
	 * the browser's default handling of a gesture such as pinch-to-zoom, or
	 * drag-to-scroll, so that the application can implement its own handling of that
	 * gesture on the element.  Suppose, for example, a component has a custom drag
	 * handler on its element and wishes to prevent horizontal scrolling of its container
	 * while it is being dragged:
	 * 
	 *     Ext.create('Ext.Widget', {
	 *         touchAction: {
	 *             panX: false
	 *         },
	 *         listeners: {
	 *             drag: function(e) {
	 *                 // implement drag logic
	 *             }
	 *         }
	 *     });
	 * 
	 */
	touchAction?: any

	/**
	 * 
	 * A string, array of strings, or a function that returns JSX.
	 * 
	 *    tpl = data => <div>{data.first_name} {data.last_name}</div>
	 * 
	 * __Note__
	 * The data configuration _must_ be set for any content to be shown in the component when using this configuration.
	 * 
	 */
	tpl?: Function | string | string[]

	/**
	 * The Ext.(X)Template method to use when updating the content area of the Component.
	 * 
	 * Valid modes are:
	 * 
	 * - append
	 * - insertAfter
	 * - insertBefore
	 * - insertFirst
	 * - overwrite
	 * 
	 */
	tplWriteMode?: string

	/**
	 * A map of transition configs. For example:
	 * 
	 *     transitions: {
	 *         select: {
	 *             duration: 500,
	 *             ease: 'cubicInOut'
	 *         },
	 *         zoom: {
	 *             name: 'zoom',
	 *             duration: 1000
	 *         },
	 *         ...
	 *     }
	 * 
	 * A class would define the defaults for its transitions, and a user only needs
	 * to set the `transitions` config of an instance to disable a transition, e.g.:
	 * 
	 *     transitions: {
	 *         // transitions are enabled by default, `true` should never be used here
	 *         select: false
	 *     }
	 * 
	 * or alter its config:
	 * 
	 *     transitions: {
	 *         select: {
	 *             // the `duration` stays the same,
	 *             // only the easing function is altered
	 *             ease: 'bounceOut'
	 *         }
	 *     }
	 * 
	 * The transitions defined this way are merely configs. To create an actual transition
	 * from one of these configs, use the createTransition method. For example:
	 * 
	 *     this.createTransition('select')
	 * 
	 * A transition object can optionally specify a name, if it's different from
	 * the key in the `transitions` config. For example:
	 * 
	 *     transitions: {
	 *         layout: {
	 *             name: 'foo',
	 *             duration: 500
	 *         }
	 *     }
	 * 
	 * Otherwise the name will be set automatically, for example:
	 * 
	 *     transition.name = this.getId() + '-' + key
	 * 
	 * Transition names (whether explicitly given or not) are prefixed by component ID
	 * to prevent transitions with the same name but on a different component from
	 * cancelling each other out.
	 * 
	 * However, transitions with the same name on the same component will still cancel
	 * each other out, if created via createTransition on the same selection
	 * or with no selection provided.
	 * 
	 * `duration`, `ease` and `name` properties of transition objects in this config
	 * are reserved, and will be used to configure a `d3.transition` instance.
	 * However, transition objects may also have other properties that are related to
	 * this transition. For example:
	 * 
	 *     transitions: {
	 *         select: {
	 *             duration: 500,
	 *             ease: 'cubicInOut',
	 *             targetScale: 1.1
	 *         }
	 *     }
	 * 
	 * The `targetScale` property here won't be consumed by a `d3.transition` instance;
	 * instead a component can make use of it in whichever way it sees fit to animate
	 * the selected element.
	 * 
	 */
	transitions?: any

	/**
	 * The ui or uis to be used on this Component
	 * 
	 * When a ui is configured, CSS class names are added to the element, created
	 * by appending the ui name(s) to each classCls and/or baseCls.
	 * 
	 */
	ui?: string | string[]

	/**
	 * One or more CSS classes to add to the component's primary element. This config
	 * is intended solely for use by the component instantiator (the "user"), not by
	 * derived classes.
	 * 
	 * For example:
	 * 
	 *      items: [{
	 *          xtype: 'button',
	 *          userCls: 'my-button'
	 *      ...
	 *      }]
	 * 
	 */
	userCls?: string | string[]

	/**
	 * This value controls this item's order in a Ext.Container#cfg!weighted
	 * Ext.Container (see cfg!parent).
	 * 
	 * Lower values gravitate towards the start of the container - the top in vertical layouts, the
	 * locale start side in horizontal layouts.
	 * 
	 */
	weight?: number

	/**
	 * The width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	width?: number | string

	/**
	 * The z-index to give this Component when it is rendered.
	 * 
	 * Not valid for cfg-floated Components. The Z ordering of cfg-floated
	 * Components is managed by ordering of the DOM elements.
	 * 
	 */
	zIndex?: number

	/**
	 * Fires after a Component had been added to a Container.
	 * 
	 */
	onAdded?: (me: any, container: any, index: number) => void

	/**
	 * This event fires when `cfg!bottom` changes.
	 */
	onBeforeBottomChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!centered` changes.
	 */
	onBeforeCenteredChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!disabled` changes.
	 */
	onBeforeDisabledChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!docked` changes.
	 */
	onBeforeDockedChange?: (sender: any, value: string, oldValue: string) => void

	/**
	 * This event fires when `cfg!height` changes.
	 */
	onBeforeHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!hidden` changes.
	 */
	onBeforeHiddenChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires before the Component is hidden. Hide may be vetoed by returning `false` from a handler.
	 * 
	 */
	onBeforeHide?: (me: any) => void

	/**
	 * This event fires when `cfg!left` changes.
	 */
	onBeforeLeftChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxHeight` changes.
	 */
	onBeforeMaxHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxWidth` changes.
	 */
	onBeforeMaxWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minHeight` changes.
	 */
	onBeforeMinHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minWidth` changes.
	 */
	onBeforeMinWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!right` changes.
	 */
	onBeforeRightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!scrollable` changes.
	 */
	onBeforeScrollableChange?: (sender: any, value: boolean | string | any, oldValue: boolean | string | any) => void

	/**
	 * Fires before the Component is shown. Show may be vetoed by returning `false` from a handler.
	 * 
	 */
	onBeforeShow?: (me: any) => void

	/**
	 * This event fires when `cfg!top` changes.
	 */
	onBeforeTopChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!width` changes.
	 */
	onBeforeWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires when this Component's focusEl loses focus.
	 * 
	 */
	onBlur?: (me: any, event: any) => void

	/**
	 * This event fires when `cfg!bottom` changes.
	 */
	onBottomChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!centered` changes.
	 */
	onCenteredChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires when the component is destroyed
	 * 
	 */
	onDestroy?: () => void

	/**
	 * This event fires when `cfg!disabled` changes.
	 */
	onDisabledChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!docked` changes.
	 */
	onDockedChange?: (sender: any, value: string, oldValue: string) => void

	/**
	 * Fires when the component is no longer displayed in the DOM.  Listening to this event will
	 * degrade performance not recommend for general use.
	 * 
	 */
	onErased?: (me: any) => void

	/**
	 * Fires when this Component's focusEl receives focus.
	 * 
	 */
	onFocus?: (me: any, event: any) => void

	/**
	 * Fires when focus enters this Component's hierarchy.
	 * 
	 */
	onFocusEnter?: (me: any, event: any) => void

	/**
	 * Fires when focus leaves this Component's hierarchy.
	 * 
	 */
	onFocusLeave?: (me: any, event: any) => void

	/**
	 * Fires whenever a Component with the fullscreen config is instantiated
	 * 
	 */
	onFullscreen?: (me: any) => void

	/**
	 * This event fires when `cfg!height` changes.
	 */
	onHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!hidden` changes.
	 */
	onHiddenChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires whenever the Component is hidden
	 * 
	 */
	onHide?: (me: any) => void

	/**
	 * Fires when the component has been initialized
	 * 
	 */
	onInitialize?: (me: any) => void

	/**
	 * This event fires when `cfg!left` changes.
	 */
	onLeftChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxHeight` changes.
	 */
	onMaxHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxWidth` changes.
	 */
	onMaxWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minHeight` changes.
	 */
	onMinHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minWidth` changes.
	 */
	onMinWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires when a component si moved within its Container.
	 * 
	 */
	onMoved?: (me: any, container: any, toIndex: number, fromIndex: number) => void

	/**
	 * Fires whenever this Element actually becomes visible (painted) on the screen. This is useful when you need to
	 * perform 'read' operations on the DOM element, i.e: calculating natural sizes and positioning.
	 * 
	 * __Note:__ This event is not available to be used with event delegation. Instead `painted` only fires if you explicitly
	 * add at least one listener to it, for performance reasons.
	 * 
	 */
	onPainted?: (element: any) => void

	/**
	 * Fires whenever there is a change in the positioned status of a component
	 * 
	 */
	onPositionedChange?: (me: any, positioned: boolean) => void

	/**
	 * Fires when a component is removed from a Container
	 * 
	 */
	onRemoved?: (me: any, container: any, index: number) => void

	/**
	 * Fires *asynchronously* after a browser layout caused by a component resize. This may be triggered for any or
	 * several of the following reasons:
	 *    - Programmatic changes to cfg-width or cfg-height configs.
	 *    - Setting the cfg-flex config when the owning layout is Ext.layout.Box.
	 *    - Setting cfg-minHeight, cfg-maxHeight, cfg-minWidth or cfg-maxWidth.
	 *    - Changing device orientation.
	 *    - Changing the browser viewport size.
	 *    - Any resize caused by browser layout recalculation which may be caused by content size changes
	 *      or application of default browser layout rules.
	 * 
	 */
	onResize?: (component: any, width: string | number, height: string | number, oldWidth: string | number, oldHeight: string | number) => void

	/**
	 * This event fires when `cfg!right` changes.
	 */
	onRightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires after scene size has changed.
	 * Notes: the scene is a 'g' element, so it cannot actually have a size.
	 * The size reported is the size the drawing is supposed to fit in.
	 * 
	 */
	onSceneResize?: (component: any, scene: any, size: any) => void

	/**
	 * Fires once after the scene has been created.
	 * Note that at this time the component doesn't have a size yet.
	 * 
	 */
	onSceneSetup?: (component: any, scene: any) => void

	/**
	 * This event fires when `cfg!scrollable` changes.
	 */
	onScrollableChange?: (sender: any, value: boolean | string | any, oldValue: boolean | string | any) => void

	/**
	 * Fires whenever the Component is shown
	 * 
	 */
	onShow?: (me: any) => void

	/**
	 * This event fires when `cfg!top` changes.
	 */
	onTopChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!width` changes.
	 */
	onWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void
}

/**
 * 
 * The base class of every SVG D3 Component that can also be used standalone.
 * 
 */
declare class D3 extends React.Component<D3Props, any> { }
export interface D3Props extends FlexibleProps {

	/**
	 * An object containing ARIA attributes to be set
	 * on this Component's ARIA element. Use this to set the attributes that cannot be
	 * determined by the Component's state, such as `aria-live`, `aria-flowto`, etc.
	 * 
	 * **Note** that this config is only meaningful at the Component rendering time,
	 * and setting it after that will do nothing.
	 * 
	 */
	ariaAttributes?: any

	/**
	 * DOM selector for a child element that is to be used
	 * as description for this Component, set in `aria-describedby` attribute.
	 * The selector works the same way as ariaLabelledBy.
	 * 
	 */
	ariaDescribedBy?: string

	/**
	 * ARIA label for this Component. It is best to use
	 * ariaLabelledBy option instead, because screen readers prefer
	 * `aria-labelledby` attribute to `aria-label`. ariaLabel and
	 * ariaLabelledBy config options are mutually exclusive.
	 * 
	 */
	ariaLabel?: string

	/**
	 * DOM selector for a child element that is to be used
	 * as label for this Component, set in `aria-labelledby` attribute.
	 * If the selector is by `#id`, the label element can be any existing element,
	 * not necessarily a child of the main Component element.
	 * 
	 * ariaLabelledBy and ariaLabel config options are
	 * mutually exclusive, and `ariaLabelledBy` has the higher precedence.
	 * 
	 */
	ariaLabelledBy?: string

	/**
	 * If `true`, then, when showBy or alignTo fallback on
	 * constraint violation only takes place along the major align axis.
	 * 
	 * That is, if alignment `"l-r"` is being used, and `axisLock: true` is used, then if constraints
	 * fail, only fallback to `"r-l"` is considered.
	 * 
	 */
	axisLock?: boolean

	/**
	 * 
	 * Enables or disables bordering on this component.
	 * The following values are accepted:
	 * 
	 * - `null` or `true (default): Do nothing and allow the border to be specified by the theme.
	 * - `false`: suppress the default border provided by the theme.
	 * 
	 * Please note that enabling bordering via this config will not add a `border-color`
	 * or `border-style` CSS property to the component; you provide the `border-color`
	 * and `border-style` via CSS rule or style configuration
	 * (if not already provide by the theme).
	 * 
	 */
	border?: boolean

	/**
	 * The absolute bottom position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	bottom?: number | string

	/**
	 * Configure this as `true` to have this Component centered within its Container.
	 * Setting this value to `true` will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	centered?: boolean

	/**
	 * If the scene elements that go outside the scene and into the padding area
	 * should be clipped.
	 * Note: stock D3 components are not designed to work with this config set to `true`.
	 * 
	 */
	clipScene?: boolean

	/**
	 * The CSS class to add to this widget's element, in
	 * addition to the baseCls. In many cases, this property will be specified
	 * by the derived widget class. See userCls for adding additional CSS
	 * classes to widget instances (such as items in a Ext.Container).
	 * 
	 */
	cls?: string | string[]

	/**
	 * The CSS class used by a subclass of the D3 Component.
	 * Normally, the lower-cased name of a subclass.
	 * 
	 */
	componentCls?: string

	/**
	 * The configured element will automatically be
	 * added as the content of this component. When you pass a string, we expect it to be an element id.
	 * If the content element is hidden, we will automatically show it.
	 * 
	 */
	contentEl?: any | HTMLElement | string

	/**
	 * The initial set of data to apply to the `tpl` to
	 * update the content area of the Component.
	 * 
	 */
	data?: any

	/**
	 * Whether or not this component is disabled
	 * 
	 */
	disabled?: boolean

	/**
	 * The dock position of this component in its container. Can be `left`, `top`, `right` or `bottom`.
	 * 
	 * __Notes__
	 * 
	 * You must use a HTML5 doctype for docked `bottom` to work. To do this, simply add the following code to the HTML file:
	 * 
	 *     <!doctype html>
	 * 
	 * So your index.html file should look a little like this:
	 * 
	 *     <!doctype html>
	 *     <html>
	 *         <head>
	 *             <title>MY application title</title>
	 *             ...
	 * 
	 */
	docked?: string

	/**
	 * Configuration options to make this Component draggable
	 * 
	 */
	draggable?: any

	/**
	 * CSS class that will be added to focused
	 * component's focusClsEl, and removed when component blurs.
	 * 
	 */
	focusCls?: string

	/**
	 * Force the component to take up 100% width and height available, by adding it
	 * to Ext.Viewport.
	 * 
	 */
	fullscreen?: boolean

	/**
	 * The height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	height?: number | string

	/**
	 * Whether or not this Component is hidden (its CSS `display` property is set to `none`).
	 * 
	 * Defaults to `true` for floated Components.
	 * 
	 */
	hidden?: boolean

	/**
	 * Animation effect to apply when the Component is being hidden.  Typically you want to use an
	 * outbound animation type such as 'fadeOut' or 'slideOut'. For more animations, check the Ext.fx.Animation#type config.
	 * 
	 */
	hideAnimation?: string | any

	/**
	 * When using a cfg!modal Component, setting this to `true`
	 * will hide the modal mask and the Container when the mask is tapped on.
	 * 
	 */
	hideOnMaskTap?: boolean

	/**
	 * Optional HTML content to render inside this Component, or a reference
	 * to an existing element on the page.
	 * 
	 */
	html?: string | any | HTMLElement

	/**
	 * The list of interaction configs for this D3 component.
	 * D3 package interactions are very similar to native D3 behaviors.
	 * However, D3 behaviors, as well as event system, is incompatible
	 * with ExtJS event system. D3 package interactions may also support
	 * certain features that D3 behaviors lack, like like kinetic scrolling,
	 * elastic borders and scroll indicators (see the Ext.d3.interaction.PanZoom
	 * interaction for more information).
	 * 
	 */
	interactions?: any[]

	/**
	 * An object containing handlers for keyboard events. The property names of this
	 * object are the key name and any modifiers. The values of the properties are the
	 * descriptors of how to handle each event.
	 * 
	 * The handler descriptor can be simply the handler function (either the
	 * literal function or the method name), or it can be an object with these
	 * properties:
	 * 
	 *  - `handler`: The function or its name to call to handle the event.
	 *  - `scope`: The this pointer context (can be "this" or "controller").
	 *  - `event`: An optional override of the key event to which to listen.
	 * 
	 * **Important:** Calls to `setKeyMap` do not replace the entire `keyMap` but
	 * instead update the provided mappings. That is, unless `null` is passed as the
	 * value of the `keyMap` which will clear the `keyMap` of all entries.
	 * 
	 */
	keyMap?: any

	/**
	 * Enables or disables processing keys in the `keyMap`. This value starts as
	 * `null` and if it is `null` when `initKeyMap` is called, it will automatically
	 * be set to `true`. Since `initKeyMap` is called by `Ext.Component` at the
	 * proper time, this is not something application code normally handles.
	 * 
	 */
	keyMapEnabled?: boolean

	/**
	 * The absolute left position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	left?: number | string

	/**
	 * 
	 * A config object containing one or more event handlers to be added to this object during initialization. This
	 * should be a valid listeners config object as specified in the
	 * addListener example for attaching
	 * multiple handlers at once.
	 * 
	 * **DOM events from Ext JS Ext.Component**
	 * 
	 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
	 * only done when extra value can be added. For example the DataView's **`itemclick`** event passing the node clicked on. To access DOM events directly from a
	 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
	 * DOM listener to:
	 * 
	 *     new Ext.panel.Panel({
	 *         width: 400,
	 *         height: 200,
	 *         dockedItems: [{
	 *             xtype: 'toolbar'
	 *         }],
	 *         listeners: {
	 *             click: {
	 *                 element: 'el', //bind to the underlying el property on the panel
	 *                 fn: function(){ console.log('click el'); }
	 *             },
	 *             dblclick: {
	 *                 element: 'body', //bind to the underlying body property on the panel
	 *                 fn: function(){ console.log('dblclick body'); }
	 *             }
	 *         }
	 *     });
	 * 
	 */
	listeners?: any

	/**
	 * The margin to use on this Component. Can be specified as a number (in which case
	 * all edges get the same margin) or a CSS string like '5 10 10 10'
	 * 
	 */
	margin?: number | string

	/**
	 * The maximum height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * Note that this config will not apply if the Component is 'positioned' (absolutely positioned or centered)
	 * 
	 */
	maxHeight?: number | string

	/**
	 * The maximum width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * Note that this config will not apply if the Component is 'positioned' (absolutely positioned or centered)
	 * 
	 */
	maxWidth?: number | string

	/**
	 * The minimum height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	minHeight?: number | string

	/**
	 * The minimum width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	minWidth?: number | string

	/**
	 * `true` to make this Component modal. This will create a mask underneath the Component
	 * that covers its parent and does not allow the user to interact with any other Components until this
	 * Component is dismissed.
	 * 
	 */
	modal?: boolean

	/**
	 * Name for the widget to be used with Ext.Container#lookupName et al.
	 * 
	 */
	name?: string

	/**
	 * The padding of the scene.
	 * See Ext.util.Format#parseBox for syntax details,
	 * if using a string for this config.
	 * 
	 */
	padding?: any | string | number

	/**
	 * An object or array of objects that will provide custom functionality for this
	 * component. If a string is provided or a string is one of the elements of the
	 * array, that string is treated as the `type` alias. For example, "listpaging"
	 * is the type alias for `Ext.plugin.ListPaging`. The full alias includes the
	 * "plugin." prefix (i.e., 'plugin.listpaging').
	 * 
	 * Plugins should derive from `Ext.plugin.Abstract` but this is not required. The
	 * only requirement for a valid plugin is that it contain an `init()` method that
	 * accepts a reference to the owning component.
	 * 
	 * When a component is created, if any plugins are available, the component will
	 * call the `init` method on each plugin,
	 * passing a reference to itself. Each plugin can then call methods or respond to
	 * events on the component as needed to provide its functionality.
	 * 
	 * ## Example code
	 * 
	 * A plugin by alias:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: 'listpaging'
	 *      });
	 * 
	 * Multiple plugins by alias:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: ['listpaging', 'pullrefresh']
	 *      });
	 * 
	 * Single plugin by class name with config options:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: {
	 *              type: 'listpaging',
	 *              autoPaging: true
	 *          }
	 *      });
	 * 
	 * Multiple plugins by type and class name with config options:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: [{
	 *              xclass: 'Ext.plugin.PullRefresh',
	 *              pullRefreshText: 'Pull to refresh...'
	 *          }, {
	 *              type: 'listpaging',
	 *              autoPaging: true
	 *          }]
	 *      });
	 * 
	 */
	plugins?: any | string | any[] | string[]

	/**
	 * A model instance which updates the Component's html based on it's tpl. Similar to the data
	 * configuration, but tied to to a record to make allow dynamic updates.  This must be a model
	 * instance and not a configuration of one.
	 * 
	 */
	record?: any

	/**
	 * Optional element to render this Component to.
	 * Not required if this component is an item of a Container of a Container.
	 * 
	 */
	renderTo?: any

	/**
	 * The absolute right position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	right?: number | string

	/**
	 * Configuration options to make this Component scrollable. Acceptable values are:
	 * 
	 * - `true` to enable auto scrolling.
	 * - `false` (or `null`) to disable scrolling - this is the default.
	 * - `x` or `horizontal` to enable horizontal scrolling only
	 * - `y` or `vertical` to enable vertical scrolling only
	 * 
	 * Also accepts a configuration object for a `Ext.scroll.Scroller` if
	 * if advanced configuration is needed.
	 * 
	 * The getter for this config returns the Ext.scroll.Scroller
	 * instance.  You can use the Scroller API to read or manipulate the scroll position:
	 * 
	 *     // scrolls the component to 5 on the x axis and 10 on the y axis
	 *     component.getScrollable().scrollTo(5, 10);
	 * 
	 */
	scrollable?: boolean | string | any

	/**
	 * Animation effect to apply when the Component is being shown.  Typically you want to use an
	 * inbound animation type such as 'fadeIn' or 'slideIn'. For more animations, check the Ext.fx.Animation#type config.
	 * 
	 */
	showAnimation?: string | any

	/**
	 * Whether or not the component got its first size.
	 * Can be used in the `sceneresize` event handler to do user-defined setup on first
	 * resize, for example:
	 * 
	 *     listeners: {
	 *         sceneresize: function (component, scene, rect) {
	 *             if (!component.size) {
	 *                 // set things up
	 *             } else {
	 *                 // handle resize
	 *             }
	 *         }
	 *     }
	 * 
	 */
	size?: any

	/**
	 * The store with data to render.
	 * 
	 */
	store?: any

	/**
	 * Additional CSS styles that will be rendered into an inline style attribute when
	 * the widget is rendered.
	 * 
	 * You can pass either a string syntax:
	 * 
	 *     style: 'background:red'
	 * 
	 * Or by using an object:
	 * 
	 *     style: {
	 *         background: 'red'
	 *     }
	 * 
	 * When using the object syntax, you can define CSS Properties by using a string:
	 * 
	 *     style: {
	 *         'border-left': '1px solid red'
	 *     }
	 * 
	 * Although the object syntax is much easier to read, we suggest you to use the
	 * string syntax for better performance.
	 * 
	 */
	style?: string | any

	/**
	 * DOM tabIndex attribute for this component's focusEl.
	 * 
	 */
	tabIndex?: number

	/**
	 * The Ext.tip.ToolTip for this component.
	 * 
	 *     <Button text="Basic Tip">
	 *         <ToolTip>A simple tooltip</ToolTip>
	 *     </Button>
	 * 
	 */
	tooltip?: any

	/**
	 * The absolute top position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	top?: number | string

	/**
	 * 
	 * Emulates the behavior of the CSS [touch-action](https://www.w3.org/TR/pointerevents/#the-touch-action-css-property)
	 * property in a cross-browser compatible manner.
	 * 
	 * Keys in this object are touch action names, and values are `false` to disable
	 * a touch action or `true` to enable it.  Accepted keys are:
	 * 
	 * - `panX`
	 * - `panY`
	 * - `pinchZoom`
	 * - `doubleTapZoom`
	 * 
	 * All touch actions are enabled (`true`) by default, so it is usually only necessary
	 * to specify which touch actions to disable.  For example, the following disables
	 * only horizontal scrolling and pinch-to-zoom on the component's main element:
	 * 
	 *     touchAction: {
	 *         panX: false,
	 *         pinchZoom: false
	 *     }
	 * 
	 * Touch actions can be specified on reference elements using the reference element
	 * name, for example:
	 * 
	 *     // disables horizontal scrolling on the main element, and double-tap-zoom
	 *     // on the child element named "body"
	 *     touchAction: {
	 *         panY: false
	 *         body: {
	 *             doubleTapZoom: false
	 *         }
	 *     }
	 * 
	 * The primary motivation for setting the touch-action of an element is to prevent
	 * the browser's default handling of a gesture such as pinch-to-zoom, or
	 * drag-to-scroll, so that the application can implement its own handling of that
	 * gesture on the element.  Suppose, for example, a component has a custom drag
	 * handler on its element and wishes to prevent horizontal scrolling of its container
	 * while it is being dragged:
	 * 
	 *     Ext.create('Ext.Widget', {
	 *         touchAction: {
	 *             panX: false
	 *         },
	 *         listeners: {
	 *             drag: function(e) {
	 *                 // implement drag logic
	 *             }
	 *         }
	 *     });
	 * 
	 */
	touchAction?: any

	/**
	 * 
	 * A string, array of strings, or a function that returns JSX.
	 * 
	 *    tpl = data => <div>{data.first_name} {data.last_name}</div>
	 * 
	 * __Note__
	 * The data configuration _must_ be set for any content to be shown in the component when using this configuration.
	 * 
	 */
	tpl?: Function | string | string[]

	/**
	 * The Ext.(X)Template method to use when updating the content area of the Component.
	 * 
	 * Valid modes are:
	 * 
	 * - append
	 * - insertAfter
	 * - insertBefore
	 * - insertFirst
	 * - overwrite
	 * 
	 */
	tplWriteMode?: string

	/**
	 * A map of transition configs. For example:
	 * 
	 *     transitions: {
	 *         select: {
	 *             duration: 500,
	 *             ease: 'cubicInOut'
	 *         },
	 *         zoom: {
	 *             name: 'zoom',
	 *             duration: 1000
	 *         },
	 *         ...
	 *     }
	 * 
	 * A class would define the defaults for its transitions, and a user only needs
	 * to set the `transitions` config of an instance to disable a transition, e.g.:
	 * 
	 *     transitions: {
	 *         // transitions are enabled by default, `true` should never be used here
	 *         select: false
	 *     }
	 * 
	 * or alter its config:
	 * 
	 *     transitions: {
	 *         select: {
	 *             // the `duration` stays the same,
	 *             // only the easing function is altered
	 *             ease: 'bounceOut'
	 *         }
	 *     }
	 * 
	 * The transitions defined this way are merely configs. To create an actual transition
	 * from one of these configs, use the createTransition method. For example:
	 * 
	 *     this.createTransition('select')
	 * 
	 * A transition object can optionally specify a name, if it's different from
	 * the key in the `transitions` config. For example:
	 * 
	 *     transitions: {
	 *         layout: {
	 *             name: 'foo',
	 *             duration: 500
	 *         }
	 *     }
	 * 
	 * Otherwise the name will be set automatically, for example:
	 * 
	 *     transition.name = this.getId() + '-' + key
	 * 
	 * Transition names (whether explicitly given or not) are prefixed by component ID
	 * to prevent transitions with the same name but on a different component from
	 * cancelling each other out.
	 * 
	 * However, transitions with the same name on the same component will still cancel
	 * each other out, if created via createTransition on the same selection
	 * or with no selection provided.
	 * 
	 * `duration`, `ease` and `name` properties of transition objects in this config
	 * are reserved, and will be used to configure a `d3.transition` instance.
	 * However, transition objects may also have other properties that are related to
	 * this transition. For example:
	 * 
	 *     transitions: {
	 *         select: {
	 *             duration: 500,
	 *             ease: 'cubicInOut',
	 *             targetScale: 1.1
	 *         }
	 *     }
	 * 
	 * The `targetScale` property here won't be consumed by a `d3.transition` instance;
	 * instead a component can make use of it in whichever way it sees fit to animate
	 * the selected element.
	 * 
	 */
	transitions?: any

	/**
	 * The ui or uis to be used on this Component
	 * 
	 * When a ui is configured, CSS class names are added to the element, created
	 * by appending the ui name(s) to each classCls and/or baseCls.
	 * 
	 */
	ui?: string | string[]

	/**
	 * One or more CSS classes to add to the component's primary element. This config
	 * is intended solely for use by the component instantiator (the "user"), not by
	 * derived classes.
	 * 
	 * For example:
	 * 
	 *      items: [{
	 *          xtype: 'button',
	 *          userCls: 'my-button'
	 *      ...
	 *      }]
	 * 
	 */
	userCls?: string | string[]

	/**
	 * This value controls this item's order in a Ext.Container#cfg!weighted
	 * Ext.Container (see cfg!parent).
	 * 
	 * Lower values gravitate towards the start of the container - the top in vertical layouts, the
	 * locale start side in horizontal layouts.
	 * 
	 */
	weight?: number

	/**
	 * The width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	width?: number | string

	/**
	 * The z-index to give this Component when it is rendered.
	 * 
	 * Not valid for cfg-floated Components. The Z ordering of cfg-floated
	 * Components is managed by ordering of the DOM elements.
	 * 
	 */
	zIndex?: number

	/**
	 * Fires after a Component had been added to a Container.
	 * 
	 */
	onAdded?: (me: any, container: any, index: number) => void

	/**
	 * This event fires when `cfg!bottom` changes.
	 */
	onBeforeBottomChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!centered` changes.
	 */
	onBeforeCenteredChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!disabled` changes.
	 */
	onBeforeDisabledChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!docked` changes.
	 */
	onBeforeDockedChange?: (sender: any, value: string, oldValue: string) => void

	/**
	 * This event fires when `cfg!height` changes.
	 */
	onBeforeHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!hidden` changes.
	 */
	onBeforeHiddenChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires before the Component is hidden. Hide may be vetoed by returning `false` from a handler.
	 * 
	 */
	onBeforeHide?: (me: any) => void

	/**
	 * This event fires when `cfg!left` changes.
	 */
	onBeforeLeftChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxHeight` changes.
	 */
	onBeforeMaxHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxWidth` changes.
	 */
	onBeforeMaxWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minHeight` changes.
	 */
	onBeforeMinHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minWidth` changes.
	 */
	onBeforeMinWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!right` changes.
	 */
	onBeforeRightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!scrollable` changes.
	 */
	onBeforeScrollableChange?: (sender: any, value: boolean | string | any, oldValue: boolean | string | any) => void

	/**
	 * Fires before the Component is shown. Show may be vetoed by returning `false` from a handler.
	 * 
	 */
	onBeforeShow?: (me: any) => void

	/**
	 * This event fires when `cfg!top` changes.
	 */
	onBeforeTopChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!width` changes.
	 */
	onBeforeWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires when this Component's focusEl loses focus.
	 * 
	 */
	onBlur?: (me: any, event: any) => void

	/**
	 * This event fires when `cfg!bottom` changes.
	 */
	onBottomChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!centered` changes.
	 */
	onCenteredChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires when the component is destroyed
	 * 
	 */
	onDestroy?: () => void

	/**
	 * This event fires when `cfg!disabled` changes.
	 */
	onDisabledChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!docked` changes.
	 */
	onDockedChange?: (sender: any, value: string, oldValue: string) => void

	/**
	 * Fires when the component is no longer displayed in the DOM.  Listening to this event will
	 * degrade performance not recommend for general use.
	 * 
	 */
	onErased?: (me: any) => void

	/**
	 * Fires when this Component's focusEl receives focus.
	 * 
	 */
	onFocus?: (me: any, event: any) => void

	/**
	 * Fires when focus enters this Component's hierarchy.
	 * 
	 */
	onFocusEnter?: (me: any, event: any) => void

	/**
	 * Fires when focus leaves this Component's hierarchy.
	 * 
	 */
	onFocusLeave?: (me: any, event: any) => void

	/**
	 * Fires whenever a Component with the fullscreen config is instantiated
	 * 
	 */
	onFullscreen?: (me: any) => void

	/**
	 * This event fires when `cfg!height` changes.
	 */
	onHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!hidden` changes.
	 */
	onHiddenChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires whenever the Component is hidden
	 * 
	 */
	onHide?: (me: any) => void

	/**
	 * Fires when the component has been initialized
	 * 
	 */
	onInitialize?: (me: any) => void

	/**
	 * This event fires when `cfg!left` changes.
	 */
	onLeftChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxHeight` changes.
	 */
	onMaxHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxWidth` changes.
	 */
	onMaxWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minHeight` changes.
	 */
	onMinHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minWidth` changes.
	 */
	onMinWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires when a component si moved within its Container.
	 * 
	 */
	onMoved?: (me: any, container: any, toIndex: number, fromIndex: number) => void

	/**
	 * Fires whenever this Element actually becomes visible (painted) on the screen. This is useful when you need to
	 * perform 'read' operations on the DOM element, i.e: calculating natural sizes and positioning.
	 * 
	 * __Note:__ This event is not available to be used with event delegation. Instead `painted` only fires if you explicitly
	 * add at least one listener to it, for performance reasons.
	 * 
	 */
	onPainted?: (element: any) => void

	/**
	 * Fires whenever there is a change in the positioned status of a component
	 * 
	 */
	onPositionedChange?: (me: any, positioned: boolean) => void

	/**
	 * Fires when a component is removed from a Container
	 * 
	 */
	onRemoved?: (me: any, container: any, index: number) => void

	/**
	 * Fires *asynchronously* after a browser layout caused by a component resize. This may be triggered for any or
	 * several of the following reasons:
	 *    - Programmatic changes to cfg-width or cfg-height configs.
	 *    - Setting the cfg-flex config when the owning layout is Ext.layout.Box.
	 *    - Setting cfg-minHeight, cfg-maxHeight, cfg-minWidth or cfg-maxWidth.
	 *    - Changing device orientation.
	 *    - Changing the browser viewport size.
	 *    - Any resize caused by browser layout recalculation which may be caused by content size changes
	 *      or application of default browser layout rules.
	 * 
	 */
	onResize?: (component: any, width: string | number, height: string | number, oldWidth: string | number, oldHeight: string | number) => void

	/**
	 * This event fires when `cfg!right` changes.
	 */
	onRightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires after scene size has changed.
	 * Notes: the scene is a 'g' element, so it cannot actually have a size.
	 * The size reported is the size the drawing is supposed to fit in.
	 * 
	 */
	onSceneResize?: (component: any, scene: any, size: any) => void

	/**
	 * Fires once after the scene has been created.
	 * Note that at this time the component doesn't have a size yet.
	 * 
	 */
	onSceneSetup?: (component: any, scene: any) => void

	/**
	 * This event fires when `cfg!scrollable` changes.
	 */
	onScrollableChange?: (sender: any, value: boolean | string | any, oldValue: boolean | string | any) => void

	/**
	 * Fires whenever the Component is shown
	 * 
	 */
	onShow?: (me: any) => void

	/**
	 * This event fires when `cfg!top` changes.
	 */
	onTopChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!width` changes.
	 */
	onWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void
}